{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"The Notebook Here is where I have decided to consolidate all of my notes on different topics in tech for easy access from anywhere without having to deal with different accounts, passwords, and 2FA. Feel free to look around but these notes were written mostly to help me better learn and remember different topics and were not written as an expert in any of the areas so mistakes are possible.","title":"The Notebook"},{"location":"#the-notebook","text":"Here is where I have decided to consolidate all of my notes on different topics in tech for easy access from anywhere without having to deal with different accounts, passwords, and 2FA. Feel free to look around but these notes were written mostly to help me better learn and remember different topics and were not written as an expert in any of the areas so mistakes are possible.","title":"The Notebook"},{"location":"data_structures/graph/","text":"Graph Theory is the mathematical theory of the properties and applications of graphs/networks Types of Graphs Undirected Graph - edges have no orientation (i.e. edge (u,v) == edge (v,u) ) Directed Graph - edges have orientations (i.e. edge (u,v) is the edge from node u to node v) Weighted Graphs - edges contain a certain weight that represent an arbitrary value such as cost, distance, quantity, etc. (Can be directed or undirected). \u200b Ex: (u, v, w) is the edge from node u to node v with a weight of w Special Graphs Tree an undirected graph with no cycles (equivalent definition- a connected graph with N nodes and N - 1 edges) Rooted Tree is a tree with a designated root node where every edge either points away from or towards the root node \u200b Arborescence (out-tree) - edges point away from the root \u200b Anti-arborescence (in-tree) - edges point towards the root Directed Acyclic Graphs (DAGs) - directed graphs with no cycles. Imporant in representing strctures with dependencies and prerequisites. (All out-trees are DAGs but not all DAGs are out-trees) Bipartite Graph - the vertices can be split into two independent groups U, V such that every edge connects between U and V. Other definitions are- the graph is two colourable or there is no odd length cycle Complete Graph - there is a unique edge between every pair of nodes (complete graph with n vertices is denoted as Kn) Representing Graphs:","title":"Graph"},{"location":"data_structures/hash-table/","text":"Hashmaps: Built on top of an array using a special indexing system. A key-value storage with fast assignments and lookup. A table that represents a map from a set of keys to a set of values. Uses a hash function which turns a key into an index into the underlying array. A hash collision is when a hash function returns the same index for two different keys. Hash collision strategies: Separate Chaining - each array index points to a different data structure (e.g. array of linked lists) Open addressing -a collision triggers a probing sequence to find where to store the value for a given key. Hash table: A key-value store that uses an array and a hashing function to save and retrieve values. Key: The identifier given to a value for later retrieval. Hash function: A function that takes some input and returns a number Compression function: A function that transforms its inputs into some smaller range of possible outputs (e.g. Hash Function) Key property is that it is not reversible Recipe for saving to a hash table: - Take the key and plug it into the hash function, getting the hash code. - Modulo that hash code by the length of the underlying array, getting an array index. - Check if the array at that index is empty, if so, save the value (and the key) there. - If the array is full at that index continue to the next possible position depending on your collision strategy. Recipe for retrieving from a hash table: - Take the key and plug it into the hash function, getting the hash code. - Modulo that hash code by the length of the underlying array, getting an array index. - Check if the array at that index has contents, if so, check the key saved there. - If the key matches the one you're looking for, return the value. - If the keys don't match, continue to the next position depending on your collision strategy.","title":"Hash table"},{"location":"data_structures/hash-table/#hashmaps","text":"Built on top of an array using a special indexing system. A key-value storage with fast assignments and lookup. A table that represents a map from a set of keys to a set of values. Uses a hash function which turns a key into an index into the underlying array. A hash collision is when a hash function returns the same index for two different keys. Hash collision strategies: Separate Chaining - each array index points to a different data structure (e.g. array of linked lists) Open addressing -a collision triggers a probing sequence to find where to store the value for a given key. Hash table: A key-value store that uses an array and a hashing function to save and retrieve values. Key: The identifier given to a value for later retrieval. Hash function: A function that takes some input and returns a number Compression function: A function that transforms its inputs into some smaller range of possible outputs (e.g. Hash Function) Key property is that it is not reversible Recipe for saving to a hash table: - Take the key and plug it into the hash function, getting the hash code. - Modulo that hash code by the length of the underlying array, getting an array index. - Check if the array at that index is empty, if so, save the value (and the key) there. - If the array is full at that index continue to the next possible position depending on your collision strategy. Recipe for retrieving from a hash table: - Take the key and plug it into the hash function, getting the hash code. - Modulo that hash code by the length of the underlying array, getting an array index. - Check if the array at that index has contents, if so, check the key saved there. - If the key matches the one you're looking for, return the value. - If the keys don't match, continue to the next position depending on your collision strategy.","title":"Hashmaps:"},{"location":"data_structures/heap/","text":"Heaps: Used to maintain a maximum or minimum value in a dataset. Commonly used to create a priority queue. Heaps tracking the maximum or minimum value are max-heaps or min-heaps. Conceptually, the tree representation is beneficial for understanding. Practically, we implement heaps in a sequential data structure like an array or list for efficiency. Think of the min-heap as a binary tree with two qualities: The root is the minimum value of the dataset. Every child\u2019s value is greater than its parent. These two properties are the defining characteristics of the min-heap. By maintaining these two properties, we can efficiently retrieve and update the minimum value. As we add elements to the heap, they\u2019re added from left to right until we\u2019ve filled the entire level. By filling the tree from left to right; we\u2019re leaving no gaps in the array. The location of each child or parent derives from a formula using the index. left child: (index * 2) + 1 right child: (index * 2) + 2 parent: (index - 1) / 2 \u2014 not used on the root! Sometimes you will add an element to the heap that violates the heap\u2019s essential properties. Ex: adding 3 as a left child of 11 in a min-heap which violates the min-heap property that children must be larger or equal to their parent. Heapifying- restoring the fundamental heap properties through swapping elements in the tree We\u2019re adding an element to the bottom of the tree and moving upwards, so we\u2019re heapifying up. As long as we\u2019ve violated the heap properties, we\u2019ll swap the offending child with its parent until we restore the properties, or until there\u2019s no parent left. If there is no parent left, that element becomes the new root of the tree.","title":"Heap"},{"location":"data_structures/heap/#heaps","text":"Used to maintain a maximum or minimum value in a dataset. Commonly used to create a priority queue. Heaps tracking the maximum or minimum value are max-heaps or min-heaps. Conceptually, the tree representation is beneficial for understanding. Practically, we implement heaps in a sequential data structure like an array or list for efficiency. Think of the min-heap as a binary tree with two qualities: The root is the minimum value of the dataset. Every child\u2019s value is greater than its parent. These two properties are the defining characteristics of the min-heap. By maintaining these two properties, we can efficiently retrieve and update the minimum value. As we add elements to the heap, they\u2019re added from left to right until we\u2019ve filled the entire level. By filling the tree from left to right; we\u2019re leaving no gaps in the array. The location of each child or parent derives from a formula using the index. left child: (index * 2) + 1 right child: (index * 2) + 2 parent: (index - 1) / 2 \u2014 not used on the root! Sometimes you will add an element to the heap that violates the heap\u2019s essential properties. Ex: adding 3 as a left child of 11 in a min-heap which violates the min-heap property that children must be larger or equal to their parent. Heapifying- restoring the fundamental heap properties through swapping elements in the tree We\u2019re adding an element to the bottom of the tree and moving upwards, so we\u2019re heapifying up. As long as we\u2019ve violated the heap properties, we\u2019ll swap the offending child with its parent until we restore the properties, or until there\u2019s no parent left. If there is no parent left, that element becomes the new root of the tree.","title":"Heaps:"},{"location":"data_structures/linked-list/","text":"Linked Lists: Are comprised of nodes The nodes contain a link to the next node (and also the previous node for bidirectional linked lists) Can be unidirectional or bidirectional Are a basic data structure, and form the basis for many other data structures Have a single head node, which serves as the first node in the list Require some maintenance in order to add or remove nodes Nodes are not located sequentially in memory like arrays since they use pointers Allows for quick insertions/removals Common Functions on Linked Lists: get the head node of the list (it\u2019s like peeking at the first item in line) add a new node to the beginning of the list print out the list values in order remove a node that has a particular value","title":"Linked list"},{"location":"data_structures/linked-list/#linked-lists","text":"Are comprised of nodes The nodes contain a link to the next node (and also the previous node for bidirectional linked lists) Can be unidirectional or bidirectional Are a basic data structure, and form the basis for many other data structures Have a single head node, which serves as the first node in the list Require some maintenance in order to add or remove nodes Nodes are not located sequentially in memory like arrays since they use pointers Allows for quick insertions/removals","title":"Linked Lists:"},{"location":"data_structures/linked-list/#common-functions-on-linked-lists","text":"get the head node of the list (it\u2019s like peeking at the first item in line) add a new node to the beginning of the list print out the list values in order remove a node that has a particular value","title":"Common Functions on Linked Lists:"},{"location":"data_structures/queue/","text":"Queues Enqueue - adds data to the \u201cback\u201d or end of the queue Dequeue - provides and removes data from the \u201cfront\u201d or beginning of the queue Peek - reveals data from the \u201cfront\u201d of the queue without removing it Queues process data First In, First Out (FIFO) Implemented using a linked list Head Node- front of queue Tail Node- back of queue Bounded Queue - a queue that has a limit on the amount of data that can be placed into it Queue Overflow - attempting to enqueue data onto an already full queue Queue Underflow - attempting to dequeue data from an empty queue Traversal or modification to other nodes within the linked list is disallowed Since both ends of the queue must be accessible, a reference to both the head node and the tail node must be maintained.","title":"Queue"},{"location":"data_structures/queue/#queues","text":"Enqueue - adds data to the \u201cback\u201d or end of the queue Dequeue - provides and removes data from the \u201cfront\u201d or beginning of the queue Peek - reveals data from the \u201cfront\u201d of the queue without removing it Queues process data First In, First Out (FIFO) Implemented using a linked list Head Node- front of queue Tail Node- back of queue Bounded Queue - a queue that has a limit on the amount of data that can be placed into it Queue Overflow - attempting to enqueue data onto an already full queue Queue Underflow - attempting to dequeue data from an empty queue Traversal or modification to other nodes within the linked list is disallowed Since both ends of the queue must be accessible, a reference to both the head node and the tail node must be maintained.","title":"Queues"},{"location":"data_structures/stack/","text":"Stacks Implemented using Linked Lists b/c it is more efficient than lists/arrays Contain data nodes Push adds data to the top of the stack Pop removes and provides data from the top of the stack Peek reveals data on the top of the stack Can have a limited size Pushing data onto a full stack results in a stack overflow Stacks process data Last In, First Out (LIFO)","title":"Stack"},{"location":"data_structures/stack/#stacks","text":"Implemented using Linked Lists b/c it is more efficient than lists/arrays Contain data nodes Push adds data to the top of the stack Pop removes and provides data from the top of the stack Peek reveals data on the top of the stack Can have a limited size Pushing data onto a full stack results in a stack overflow Stacks process data Last In, First Out (LIFO)","title":"Stacks"},{"location":"data_structures/tree/","text":"Trees: Wide- parent nodes referencing many child nodes. Deep- many parent-child relationships. Each time we move from a parent to a child, we\u2019re moving down a level. Depending on the orientation we refer to this as the depth (counting levels down from the root node) or height (counting levels up from a leaf node). Useful for modeling data that has a hierarchical relationship which moves in the direction from parent to child. No child node will have more than one parent. root: A node which has no parent. One per tree. parent: A node which references other nodes. child: Nodes referenced by other nodes. sibling: Nodes which have the same parent. leaf: Nodes which have no children. level: The height or depth of the tree. Root nodes are at level 1, their children are at level 2, and so on. Binary Search Trees Type of tree where each parent can have no more than two children, known as the left child and right child. Left child values must be lesser than their parent. Right child values must be greater than their parent.","title":"Tree"},{"location":"data_structures/tree/#trees","text":"Wide- parent nodes referencing many child nodes. Deep- many parent-child relationships. Each time we move from a parent to a child, we\u2019re moving down a level. Depending on the orientation we refer to this as the depth (counting levels down from the root node) or height (counting levels up from a leaf node). Useful for modeling data that has a hierarchical relationship which moves in the direction from parent to child. No child node will have more than one parent. root: A node which has no parent. One per tree. parent: A node which references other nodes. child: Nodes referenced by other nodes. sibling: Nodes which have the same parent. leaf: Nodes which have no children. level: The height or depth of the tree. Root nodes are at level 1, their children are at level 2, and so on.","title":"Trees:"},{"location":"data_structures/tree/#binary-search-trees","text":"Type of tree where each parent can have no more than two children, known as the left child and right child. Left child values must be lesser than their parent. Right child values must be greater than their parent.","title":"Binary Search Trees"},{"location":"databases/dbms/","text":"Database Mangament Systems (DBMS) Special software program to help create and maintain a database Easy to handle lots of info Handles security, Backups, import/exporting data, & concurrency interacts w/ software apps and programming languages Ex: Amazon.com will interact w/ the DBMS in order to create, read, update, & delete product info Relational Database (SQL) organize data into 1 or more tables Each table has columns and rows A unique key identifies each row Relation Database Management Systems (RDBMS) mySQL,Oracle,postgreSQL,mariaDB,etc Non-Relational Database (noSQL) Not organized in traditional table Key-value stores, Documents, Graphs, Flexible Tablees, etc Non-Relational Database Management Systems (NRDBMS) mongoDB,dynamoDB,apache cassandra, firebase, etc no standard language b/c each implementation is language specific","title":"DBMS"},{"location":"databases/dbms/#database-mangament-systems-dbms","text":"Special software program to help create and maintain a database Easy to handle lots of info Handles security, Backups, import/exporting data, & concurrency interacts w/ software apps and programming languages Ex: Amazon.com will interact w/ the DBMS in order to create, read, update, & delete product info","title":"Database Mangament Systems (DBMS)"},{"location":"databases/dbms/#relational-database-sql","text":"organize data into 1 or more tables Each table has columns and rows A unique key identifies each row Relation Database Management Systems (RDBMS) mySQL,Oracle,postgreSQL,mariaDB,etc","title":"Relational Database (SQL)"},{"location":"databases/dbms/#non-relational-database-nosql","text":"Not organized in traditional table Key-value stores, Documents, Graphs, Flexible Tablees, etc Non-Relational Database Management Systems (NRDBMS) mongoDB,dynamoDB,apache cassandra, firebase, etc no standard language b/c each implementation is language specific","title":"Non-Relational Database (noSQL)"},{"location":"databases/mysql/","text":"MySQL Python Access Connect to the MySQL Database, you get a MySQLConnection object. a. To connect to the database, read the database configuration parameters from config.ini using configparser and pass the resulting dictionary to the constructor of the MySQLConnection Object Instantiate a MySQLCursor object from the the MySQLConnection object. Use the cursor to execute a query by calling its execute() method. Use fetchone() , fetchmany() or fetchall() method to fetch data from the result set. Close the cursor as well as the database connection by calling the close() method of the corresponding object from mysql.connector import MySQLConnection, Error dbconfig = { 'host' = 'localhost', 'database' = 'Books', 'user' = 'root', 'password' = 'password' } conn = None try: conn = MySQLConnection(**dbconfig) cursor = conn.cursor() cursor.execute('SELECT * FROM books LIMIT 5') for row in iter_row(cursor): print(row) except Error as e: print(e) finally: cursor.close() conn.close() Generator that chunks the database calls into a series of fetchmany() calls def iter_row(cursor,size=10): while True: rows = cursor.fetchmany(size) if not rows: break for row in rows: yield row","title":"MySQL"},{"location":"databases/mysql/#mysql","text":"","title":"MySQL"},{"location":"databases/mysql/#python-access","text":"Connect to the MySQL Database, you get a MySQLConnection object. a. To connect to the database, read the database configuration parameters from config.ini using configparser and pass the resulting dictionary to the constructor of the MySQLConnection Object Instantiate a MySQLCursor object from the the MySQLConnection object. Use the cursor to execute a query by calling its execute() method. Use fetchone() , fetchmany() or fetchall() method to fetch data from the result set. Close the cursor as well as the database connection by calling the close() method of the corresponding object from mysql.connector import MySQLConnection, Error dbconfig = { 'host' = 'localhost', 'database' = 'Books', 'user' = 'root', 'password' = 'password' } conn = None try: conn = MySQLConnection(**dbconfig) cursor = conn.cursor() cursor.execute('SELECT * FROM books LIMIT 5') for row in iter_row(cursor): print(row) except Error as e: print(e) finally: cursor.close() conn.close() Generator that chunks the database calls into a series of fetchmany() calls def iter_row(cursor,size=10): while True: rows = cursor.fetchmany(size) if not rows: break for row in rows: yield row","title":"Python Access"},{"location":"databases/sql/","text":"Structured Query Language (SQL) Standardized language for interacting w/ RDBMS used to perform CRUD operations and other admin tasks(e.g user managment, security, backup, etc) SQL code on one RDBMS might not be portable to a different RDBMS b/c SQL implementations vary btw systems 4 Types of Languages in SQL: Data Query Language (DQL) - queries the DB for stored info Data Definition Language (DDL) - defines database schemas Data Control Language (DCL) - controls access to data in DB & manages users and permissions Data Manipulation Laguage (DML) - inserts, updates, and deletes data from DB Keys Primary Key - attribute that is unique for each row in the table Surrogate Key - type of primary key that has no mapping to anything in the real world Natural Key - type of primary key that has a mapping to the real world (e.g. SSN) Foreign Key - stores the primary key of a row in another database table (Link to another table) Can define relationships between tables or within a table Composite Key - type of primary key that is made up of two attributes Used when either of the attributes on their own do not uniquely identify a row Datatypes INT DECIMAL(M,N) -- m: total # digits, n: # digits after decimal place VARCHAR(L) -- String of text of max length L BLOB -- Binary large objects, stores large data like images DATE -- 'YYYY-MM-DD' TIMESTAMP -- 'YYYY-MM-DD HH:MM:SS' Functions --Find Num of Students SELECT COUNT(student_id) FROM students; --Find Num of female student born after 1980 SELECT COUNT(student_id) FROM students WHERE sex = 'F' AND birth_date > '1981-01-01'; --Find avg male salary SELECT AVG(salary) FROM employees WHERE sex = 'M'; --Find sum of all salaries SELECT SUM(salary) FROM employees; --Find num of males & females SELECT COUNT(sex), sex FROM employe GROUP BY sex; --Group By command used for aggregation Queries SELECT student.name AS forename, student.major FROM student ORDER BY name DESC --Descending alphabetical order LIMIT 20; --limits # of entries returned -- Comparison Operators: <, >, <=, >=, =, AND, OR, <> (not equal to) Tables CREATE TABLE student ( student_id INT AUTO_INCREMENT, -- you don't have to insert a primary key b/c its auto incremented name VARCHAR(20) UNIQUE, major VARCHAR(20) DEFAULT 'undecided', PRIMARY KEY(student_id) ); -- Delete a Table DROP TABLE student; --Show the table schema DESCRIBE student; -- Add & Drop Attributes ALTER TABLE student ADD gpa DECIMAL(3,2); ALTER TABLE student DROP COLUMN gpa; Insert, Update, Delete INSERT INTO student VALUES(1,'Jack','Biology'); INSERT INTO student(name) VALUES('Kate'); UPDATE student SET major = 'Computer Science and Engineering' WHERE major = 'Computer Science' OR major = 'Computer Engineering'; DELETE FROM student WHERE student_id > 100;","title":"SQL"},{"location":"databases/sql/#structured-query-language-sql","text":"Standardized language for interacting w/ RDBMS used to perform CRUD operations and other admin tasks(e.g user managment, security, backup, etc) SQL code on one RDBMS might not be portable to a different RDBMS b/c SQL implementations vary btw systems","title":"Structured Query Language (SQL)"},{"location":"databases/sql/#4-types-of-languages-in-sql","text":"Data Query Language (DQL) - queries the DB for stored info Data Definition Language (DDL) - defines database schemas Data Control Language (DCL) - controls access to data in DB & manages users and permissions Data Manipulation Laguage (DML) - inserts, updates, and deletes data from DB","title":"4 Types of Languages in SQL:"},{"location":"databases/sql/#keys","text":"Primary Key - attribute that is unique for each row in the table Surrogate Key - type of primary key that has no mapping to anything in the real world Natural Key - type of primary key that has a mapping to the real world (e.g. SSN) Foreign Key - stores the primary key of a row in another database table (Link to another table) Can define relationships between tables or within a table Composite Key - type of primary key that is made up of two attributes Used when either of the attributes on their own do not uniquely identify a row","title":"Keys"},{"location":"databases/sql/#datatypes","text":"INT DECIMAL(M,N) -- m: total # digits, n: # digits after decimal place VARCHAR(L) -- String of text of max length L BLOB -- Binary large objects, stores large data like images DATE -- 'YYYY-MM-DD' TIMESTAMP -- 'YYYY-MM-DD HH:MM:SS'","title":"Datatypes"},{"location":"databases/sql/#functions","text":"--Find Num of Students SELECT COUNT(student_id) FROM students; --Find Num of female student born after 1980 SELECT COUNT(student_id) FROM students WHERE sex = 'F' AND birth_date > '1981-01-01'; --Find avg male salary SELECT AVG(salary) FROM employees WHERE sex = 'M'; --Find sum of all salaries SELECT SUM(salary) FROM employees; --Find num of males & females SELECT COUNT(sex), sex FROM employe GROUP BY sex; --Group By command used for aggregation","title":"Functions"},{"location":"databases/sql/#queries","text":"SELECT student.name AS forename, student.major FROM student ORDER BY name DESC --Descending alphabetical order LIMIT 20; --limits # of entries returned -- Comparison Operators: <, >, <=, >=, =, AND, OR, <> (not equal to)","title":"Queries"},{"location":"databases/sql/#tables","text":"CREATE TABLE student ( student_id INT AUTO_INCREMENT, -- you don't have to insert a primary key b/c its auto incremented name VARCHAR(20) UNIQUE, major VARCHAR(20) DEFAULT 'undecided', PRIMARY KEY(student_id) ); -- Delete a Table DROP TABLE student; --Show the table schema DESCRIBE student; -- Add & Drop Attributes ALTER TABLE student ADD gpa DECIMAL(3,2); ALTER TABLE student DROP COLUMN gpa;","title":"Tables"},{"location":"databases/sql/#insert-update-delete","text":"INSERT INTO student VALUES(1,'Jack','Biology'); INSERT INTO student(name) VALUES('Kate'); UPDATE student SET major = 'Computer Science and Engineering' WHERE major = 'Computer Science' OR major = 'Computer Engineering'; DELETE FROM student WHERE student_id > 100;","title":"Insert, Update, Delete"},{"location":"general/git/","text":"Git Cheat Sheet Setup Repo git init initializes an existing directory as a git repo git clone <url> retrieves an entire remote repository Add Branch Local: git branch <new-branch> will create a new local branch from the branch you are currently located on but will not automatically check it out git checkout -b <new-branch> will create and automatically checkout a new local-branch Remote: git push --set-upstream origin <local-branch> will add your new local branch to the remote repo git push -u origin <local-branch> uses the -u flag as shorthand Delete Branch Local: git branch -d <local-branch> -d flag will refuse to delete the branch when it contains commits not merged into other local branches or pushed to a remote repo -D flag will delete such a branch regardless (force deletion) Remote: git push origin --delete <remote-branch-name> Stash Changes Stashing can be used to temporaliy store modified, tracked files in order to change branches git stash saves the modified and staged changes git stash list lists the stack of stashed file changes git stash pop writes working from the top of the stash stack git stash drop discards the changes from the top of the stash stack Commit Hashes Git generates a unique SHA-1 hash (40 char string of hex digits) for every commit and refers to commits by this ID (usually only displays first 7 digits) SHA-1 has been compromised (can spoof hashes) so they are moving to SHA-256 Making changes to previous commits in .git can be detected b/c each commit's hash is based on the previous commit's hash so the change to a previous commit would be easily detected Simple blockchain of basing commit hashes on previous commits and verifying chains of hashes","title":"Git"},{"location":"general/git/#git-cheat-sheet","text":"","title":"Git Cheat Sheet"},{"location":"general/git/#setup-repo","text":"git init initializes an existing directory as a git repo git clone <url> retrieves an entire remote repository","title":"Setup Repo"},{"location":"general/git/#add-branch","text":"Local: git branch <new-branch> will create a new local branch from the branch you are currently located on but will not automatically check it out git checkout -b <new-branch> will create and automatically checkout a new local-branch Remote: git push --set-upstream origin <local-branch> will add your new local branch to the remote repo git push -u origin <local-branch> uses the -u flag as shorthand","title":"Add Branch"},{"location":"general/git/#delete-branch","text":"Local: git branch -d <local-branch> -d flag will refuse to delete the branch when it contains commits not merged into other local branches or pushed to a remote repo -D flag will delete such a branch regardless (force deletion) Remote: git push origin --delete <remote-branch-name>","title":"Delete Branch"},{"location":"general/git/#stash-changes","text":"Stashing can be used to temporaliy store modified, tracked files in order to change branches git stash saves the modified and staged changes git stash list lists the stack of stashed file changes git stash pop writes working from the top of the stash stack git stash drop discards the changes from the top of the stash stack","title":"Stash Changes"},{"location":"general/git/#commit-hashes","text":"Git generates a unique SHA-1 hash (40 char string of hex digits) for every commit and refers to commits by this ID (usually only displays first 7 digits) SHA-1 has been compromised (can spoof hashes) so they are moving to SHA-256 Making changes to previous commits in .git can be detected b/c each commit's hash is based on the previous commit's hash so the change to a previous commit would be easily detected Simple blockchain of basing commit hashes on previous commits and verifying chains of hashes","title":"Commit Hashes"},{"location":"general/hardware/","text":"3D Modeling and Printing Process Design or download a model (.stl file) Import the stl file(s) to slicing software (e.g. IdeaMaker) Slice the object Slicing takes the model and does the math on it to create gcode instructions for the 3D printer Export the gcode instructions to a usb drive or SD card depending on the printer Plug in drive to printer and begin the 3D print Notes PLA is a common plastic used b/c it is softer (less wear & tear on printer) and needs less heat to be melted ABS is a harder plastic that is used and thus requires more heat to melt it A variety of different filaments can be used to print things Tiny errors in a 3D printer\u2019s movement results in big errors with the print b/c movements are done hundreds of times Raspberry Pi Board Structure Set of GPIO pins (General purpose input-output pins) Read More Serial pin on TX (GPIO14) and RX (GPIO15) Can print out this and place on pi for reference Interactive GPIO Guide Pi Camera Watch out, static can kill it FIX PI CAMERA DETECTION ERROR by enabling the I2C Interface in preferences --> raspberry pi configuration Quartus Software used for designing circuits and implementing them on a board such as the FPGA used in lab. Project Structure Digital systems lab folder/project Within the folder each design follows the format lab#design#.bdf .bdf stands for block design format Simulating a Circuit Create a new University Program VWF (vector waveform file) Place in the project's directory Setup scaling: Set end time to be 16 micro/nano seconds Set grid time to be 1 micro/nano seconds View -> Fit in Window Insert all the input and output nodes Only ones that were compiled will show up Edit -> Value -> Overwrite Clock (Ctrl + Alt + K) to set the period to 2 microseconds, 4 microseconds, etc. This simulates counting and is setup manually can setup automatic counting by grouping inputs together Simulation -> Run Functional Simulation Will create several new files and display the output waveform as readonly This is how you can verify your circuit worked correctly","title":"Hardware"},{"location":"general/hardware/#3d-modeling-and-printing","text":"","title":"3D Modeling and Printing"},{"location":"general/hardware/#process","text":"Design or download a model (.stl file) Import the stl file(s) to slicing software (e.g. IdeaMaker) Slice the object Slicing takes the model and does the math on it to create gcode instructions for the 3D printer Export the gcode instructions to a usb drive or SD card depending on the printer Plug in drive to printer and begin the 3D print","title":"Process"},{"location":"general/hardware/#notes","text":"PLA is a common plastic used b/c it is softer (less wear & tear on printer) and needs less heat to be melted ABS is a harder plastic that is used and thus requires more heat to melt it A variety of different filaments can be used to print things Tiny errors in a 3D printer\u2019s movement results in big errors with the print b/c movements are done hundreds of times","title":"Notes"},{"location":"general/hardware/#raspberry-pi","text":"","title":"Raspberry Pi"},{"location":"general/hardware/#board-structure","text":"Set of GPIO pins (General purpose input-output pins) Read More Serial pin on TX (GPIO14) and RX (GPIO15) Can print out this and place on pi for reference Interactive GPIO Guide","title":"Board Structure"},{"location":"general/hardware/#pi-camera","text":"Watch out, static can kill it FIX PI CAMERA DETECTION ERROR by enabling the I2C Interface in preferences --> raspberry pi configuration","title":"Pi Camera"},{"location":"general/hardware/#quartus","text":"Software used for designing circuits and implementing them on a board such as the FPGA used in lab.","title":"Quartus"},{"location":"general/hardware/#project-structure","text":"Digital systems lab folder/project Within the folder each design follows the format lab#design#.bdf .bdf stands for block design format","title":"Project Structure"},{"location":"general/hardware/#simulating-a-circuit","text":"Create a new University Program VWF (vector waveform file) Place in the project's directory Setup scaling: Set end time to be 16 micro/nano seconds Set grid time to be 1 micro/nano seconds View -> Fit in Window Insert all the input and output nodes Only ones that were compiled will show up Edit -> Value -> Overwrite Clock (Ctrl + Alt + K) to set the period to 2 microseconds, 4 microseconds, etc. This simulates counting and is setup manually can setup automatic counting by grouping inputs together Simulation -> Run Functional Simulation Will create several new files and display the output waveform as readonly This is how you can verify your circuit worked correctly","title":"Simulating a Circuit"},{"location":"general/macos/","text":"MacOS Overview Executable PATH PATH is an environment variable that contains a colon-seperated list of directories where your shell will look for executables that are called by name on the command line without an explicit path to them Ex: /usr/bin:/bin:/home/bin Any executable called by name will be searched for in these directories in the order from left to right if an executable exists in 2 directories, the one that is found first is executed If no executable is found in any of the directories on the path, the shell will not execute the command and will throw a command not recognized error /etc/paths sets the PATH system wide for all users (macOS specific) .~/zsh_profile sets per-user preferences ( ~ is the user's home directory) PATH , $PATH , and ${PATH} all reference the same variable just in different contexts PATH is for setting the variable (e.g. PATH=/usr/bin ) $ denotes an environment variable variable names are case sensitive so PATH is different than Path Bash/zsh Profile vs RC: .bash_profile is executed for login shells (e.g. logging into machine via console or via ssh) .bashrc is executed for interactive non-login shells (e.g. already logged in and open a new terminal window) Also run when starting a new bash instance by typing /bin/bash such as the shebang at the top of some python scripts In OSX, terminal runs a login shell every time by default unlike other operating systems Filesystem Does not follow the Filesystem Hierarchy Standard that Linux operating systems do so there are some similarities and differences / is the root of the MacOS filesystem /System/Library/Kernels : Contains the OS kernel (replaces /boot folder in FHS) /Users : replaces the /home folder in FHS /var/root/ : replaces the /root folder in FHS /usr contains user installed utilities and apps user commands: /usr/bin for normal users /usr/sbin for admin users shared libraries: /usr/lib Man pages (manual page- software documentation) /usr/share/man executables that shouldn't directly be run by users /usr/libexec a subdirectory to place programs, libraries, and other files that don't come with the base OS /usr/local /dev contains device files /etc contains system configuration files and scripts /etc/paths contains a list of paths used by path_helper to build and set the PATH to search for commands along /bin contians executables to provide essential user utilities (e.g common command line commands like ls or pwd or cd) man hier : / root directory of the filesystem /bin/ user utilities fundamental to both single-user and multi-user environments /dev/ block and character device files /etc/ system configuration files and scripts /mach_kernel kernel executable (the operating system loaded into memory at boot time). /sbin/ system programs and administration utilities fundamental to both single-user and multi- user environments /tmp/ temporary files /usr/ contains the majority of user utilities and applications bin/ common utilities, programming tools, and apps include/ standard C include files arpa/ C include files for Internet service protocols hfs/ C include files for HFS machine/ machine specific C include files net/ misc network C include files netinet/ C include files for Internet standard protocols; see inet(4) nfs/ C include files for NFS (Network File System) objc/ C include files for Objective-C protocols/ C include files for Berkeley service protocols sys/ system C include files (kernel data structures) ufs/ C include files for UFS lib/ archive libraries libexec/ system daemons & system utilities (executed by other programs) local/ executables, libraries, etc. not included by the basic OS sbin/ system daemons & system utilities (executed by users) share/ architecture-independent data files calendar/ a variety of pre-fab calendar files dict/ word lists man/ manual pages misc/ misc system-wide ascii text files mk/ templates for make skel/ example . (dot) files for new accounts tabset/ tab description files zoneinfo/ timezone configuration information /var/ multi-purpose log, temporary, transient, and spool files at/ timed command scheduling files; see at(1) backups/ misc. backup files db/ misc. automatically generated system-specific database files log/ misc. system log files mail/ user mailbox files run/ system information files describing various info about system since it was booted rwho/ rwho data files spool/ misc. printer and mail system spooling directories tmp/ temporary files that are kept between system reboots folders/ per-user temporary files and caches Useful Commands man cmd will display the manual page for the terminal command (useful for getting the flag descriptions for commands like ls ) | pipe operator is great for doing additional commands to the output of the first command echo \"source /opt/ros/foxy/setup.zsh\" >> .zshrc is useful for adding things to the .zshrc without opening it up in an editor which python3 is usefull for figuring out where commands/executables are installed on the PATH compaudit | xargs chmod g-w basically runs an audit for insecure directories (usually related to read-write permissions) and removes any write permissions that should not be on directories ( Source ) needed to use this to fix a compaudit warning when sourcing ros2-foxy-base Resources MacOS Filesystem PATH Explanation Bash Profile vs RC Homebrew symlinks in /usr/local/opt to /usr/local/Cellar","title":"MacOS"},{"location":"general/macos/#macos-overview","text":"","title":"MacOS Overview"},{"location":"general/macos/#executable-path","text":"PATH is an environment variable that contains a colon-seperated list of directories where your shell will look for executables that are called by name on the command line without an explicit path to them Ex: /usr/bin:/bin:/home/bin Any executable called by name will be searched for in these directories in the order from left to right if an executable exists in 2 directories, the one that is found first is executed If no executable is found in any of the directories on the path, the shell will not execute the command and will throw a command not recognized error /etc/paths sets the PATH system wide for all users (macOS specific) .~/zsh_profile sets per-user preferences ( ~ is the user's home directory) PATH , $PATH , and ${PATH} all reference the same variable just in different contexts PATH is for setting the variable (e.g. PATH=/usr/bin ) $ denotes an environment variable variable names are case sensitive so PATH is different than Path","title":"Executable PATH"},{"location":"general/macos/#bashzsh-profile-vs-rc","text":".bash_profile is executed for login shells (e.g. logging into machine via console or via ssh) .bashrc is executed for interactive non-login shells (e.g. already logged in and open a new terminal window) Also run when starting a new bash instance by typing /bin/bash such as the shebang at the top of some python scripts In OSX, terminal runs a login shell every time by default unlike other operating systems","title":"Bash/zsh Profile vs RC:"},{"location":"general/macos/#filesystem","text":"Does not follow the Filesystem Hierarchy Standard that Linux operating systems do so there are some similarities and differences / is the root of the MacOS filesystem /System/Library/Kernels : Contains the OS kernel (replaces /boot folder in FHS) /Users : replaces the /home folder in FHS /var/root/ : replaces the /root folder in FHS /usr contains user installed utilities and apps user commands: /usr/bin for normal users /usr/sbin for admin users shared libraries: /usr/lib Man pages (manual page- software documentation) /usr/share/man executables that shouldn't directly be run by users /usr/libexec a subdirectory to place programs, libraries, and other files that don't come with the base OS /usr/local /dev contains device files /etc contains system configuration files and scripts /etc/paths contains a list of paths used by path_helper to build and set the PATH to search for commands along /bin contians executables to provide essential user utilities (e.g common command line commands like ls or pwd or cd) man hier : / root directory of the filesystem /bin/ user utilities fundamental to both single-user and multi-user environments /dev/ block and character device files /etc/ system configuration files and scripts /mach_kernel kernel executable (the operating system loaded into memory at boot time). /sbin/ system programs and administration utilities fundamental to both single-user and multi- user environments /tmp/ temporary files /usr/ contains the majority of user utilities and applications bin/ common utilities, programming tools, and apps include/ standard C include files arpa/ C include files for Internet service protocols hfs/ C include files for HFS machine/ machine specific C include files net/ misc network C include files netinet/ C include files for Internet standard protocols; see inet(4) nfs/ C include files for NFS (Network File System) objc/ C include files for Objective-C protocols/ C include files for Berkeley service protocols sys/ system C include files (kernel data structures) ufs/ C include files for UFS lib/ archive libraries libexec/ system daemons & system utilities (executed by other programs) local/ executables, libraries, etc. not included by the basic OS sbin/ system daemons & system utilities (executed by users) share/ architecture-independent data files calendar/ a variety of pre-fab calendar files dict/ word lists man/ manual pages misc/ misc system-wide ascii text files mk/ templates for make skel/ example . (dot) files for new accounts tabset/ tab description files zoneinfo/ timezone configuration information /var/ multi-purpose log, temporary, transient, and spool files at/ timed command scheduling files; see at(1) backups/ misc. backup files db/ misc. automatically generated system-specific database files log/ misc. system log files mail/ user mailbox files run/ system information files describing various info about system since it was booted rwho/ rwho data files spool/ misc. printer and mail system spooling directories tmp/ temporary files that are kept between system reboots folders/ per-user temporary files and caches","title":"Filesystem"},{"location":"general/macos/#useful-commands","text":"man cmd will display the manual page for the terminal command (useful for getting the flag descriptions for commands like ls ) | pipe operator is great for doing additional commands to the output of the first command echo \"source /opt/ros/foxy/setup.zsh\" >> .zshrc is useful for adding things to the .zshrc without opening it up in an editor which python3 is usefull for figuring out where commands/executables are installed on the PATH compaudit | xargs chmod g-w basically runs an audit for insecure directories (usually related to read-write permissions) and removes any write permissions that should not be on directories ( Source ) needed to use this to fix a compaudit warning when sourcing ros2-foxy-base","title":"Useful Commands"},{"location":"general/macos/#resources","text":"MacOS Filesystem PATH Explanation Bash Profile vs RC Homebrew symlinks in /usr/local/opt to /usr/local/Cellar","title":"Resources"},{"location":"general/oop/","text":"Object Oriented Programming: What is a Class: A blueprint Fields (instance variables) What an object knows Methods(Functions) What an object does What is Inheritance: Parent/Super class that shares fields/methods with its subclasses that also have their own fields & methods Subclasses abstract out the super class's features Subclasses can override or extend methods that don't work Subclasses only define the changes since the super's fields & methods are already defined when you extend the super class Use is A? principle to decide whether to extend a class Ex: Is a Dog an Animal? Yes, so Dog extends Animal Ex: Is a Dog a cat? No, so Dog doesn't extend Cat Use inheritance when a subclass needs most of the methods in the superclass Do not use inheritance just to reuse code if is A? doesn't work class Animal{ private String name; private double height; private int weight; private String sound; public void setName(String newName){ name = newName; } public void setSound(String newSound){ sound = newSound; } } class Dog extends Animal{ public Dog(){ super(); //Calls super constructor setSound(\"Bark\"); } public void digHole(){ System.out.println(\"Hole dug\"); } } What is Encapsulation: Protects data Use private fields Do not set fields directly Use public getter & setter functions to access & change the data Setter = Mutator Getter = Accessor class Dog{ private double height; public void setHeight(newHeight){ if(newHeight > 0){ height = newHeight; } else{ //Throw an Error } } } Instance vs. Local Variables: Instance Variable(AKA fields) are declared in a class Local Variables are declared in a method What is Polymorphism: Allows you to write methods that don't need to change if new subclasses are created Ex: Dog can add a new method w/o changing Animal Allows you to put diff subclasses in one array Animal doggy = new Dog(); Animal kitty = new Cat(); Animal[] animals = [doggy,kitty]; kitty.getSound(); //Returns Meow doggy.digHole(); //Would not work ((Dog)doggy).digHole(); //Would Work You can't access methods this way if they are only in the subclass Need to cast the object to the subclass that contains that method Cannot reference non-static variables or non-static-methods(w/o an object) in a static method Cannot access private methods outside of a subclass/class What is an Abstract Class: Gives power of polymorphism w/o all the work There are no abstract fields but can have protected variables that are rewritten as private fields in subclasses All methods do not have to be abstract w/in an abstract class You can have static methods w/in abstract classes Cannot create objects from abstract classes but subclasses can extend them and be made into objects Have to override abstract methods in the subclass in order to extend the class abstract public Class Creature{ protected String name; public abstract void setName(newName); } What is an Interface: A class w/ only abstract methods Can implement as many interfaces to a class as you want Can only use public static and final fields Provide the ultimate flexibility Classes from different inheritance trees can use a common interface Avoid using interfaces just to force the creation of a method public interface Living { public void setName(String newName); } public class Monkey implements Living{ private name; public void setName(String newName){ name = newName; } }","title":"Oop"},{"location":"general/oop/#object-oriented-programming","text":"","title":"Object Oriented Programming:"},{"location":"general/oop/#what-is-a-class","text":"A blueprint Fields (instance variables) What an object knows Methods(Functions) What an object does","title":"What is a Class:"},{"location":"general/oop/#what-is-inheritance","text":"Parent/Super class that shares fields/methods with its subclasses that also have their own fields & methods Subclasses abstract out the super class's features Subclasses can override or extend methods that don't work Subclasses only define the changes since the super's fields & methods are already defined when you extend the super class Use is A? principle to decide whether to extend a class Ex: Is a Dog an Animal? Yes, so Dog extends Animal Ex: Is a Dog a cat? No, so Dog doesn't extend Cat Use inheritance when a subclass needs most of the methods in the superclass Do not use inheritance just to reuse code if is A? doesn't work class Animal{ private String name; private double height; private int weight; private String sound; public void setName(String newName){ name = newName; } public void setSound(String newSound){ sound = newSound; } } class Dog extends Animal{ public Dog(){ super(); //Calls super constructor setSound(\"Bark\"); } public void digHole(){ System.out.println(\"Hole dug\"); } }","title":"What is Inheritance:"},{"location":"general/oop/#what-is-encapsulation","text":"Protects data Use private fields Do not set fields directly Use public getter & setter functions to access & change the data Setter = Mutator Getter = Accessor class Dog{ private double height; public void setHeight(newHeight){ if(newHeight > 0){ height = newHeight; } else{ //Throw an Error } } }","title":"What is Encapsulation:"},{"location":"general/oop/#instance-vs-local-variables","text":"Instance Variable(AKA fields) are declared in a class Local Variables are declared in a method","title":"Instance vs. Local Variables:"},{"location":"general/oop/#what-is-polymorphism","text":"Allows you to write methods that don't need to change if new subclasses are created Ex: Dog can add a new method w/o changing Animal Allows you to put diff subclasses in one array Animal doggy = new Dog(); Animal kitty = new Cat(); Animal[] animals = [doggy,kitty]; kitty.getSound(); //Returns Meow doggy.digHole(); //Would not work ((Dog)doggy).digHole(); //Would Work You can't access methods this way if they are only in the subclass Need to cast the object to the subclass that contains that method Cannot reference non-static variables or non-static-methods(w/o an object) in a static method Cannot access private methods outside of a subclass/class","title":"What is Polymorphism:"},{"location":"general/oop/#what-is-an-abstract-class","text":"Gives power of polymorphism w/o all the work There are no abstract fields but can have protected variables that are rewritten as private fields in subclasses All methods do not have to be abstract w/in an abstract class You can have static methods w/in abstract classes Cannot create objects from abstract classes but subclasses can extend them and be made into objects Have to override abstract methods in the subclass in order to extend the class abstract public Class Creature{ protected String name; public abstract void setName(newName); }","title":"What is an Abstract Class:"},{"location":"general/oop/#what-is-an-interface","text":"A class w/ only abstract methods Can implement as many interfaces to a class as you want Can only use public static and final fields Provide the ultimate flexibility Classes from different inheritance trees can use a common interface Avoid using interfaces just to force the creation of a method public interface Living { public void setName(String newName); } public class Monkey implements Living{ private name; public void setName(String newName){ name = newName; } }","title":"What is an Interface:"},{"location":"general/paradigms/","text":"What is a Programming Paradigm? A style of programming/way of thinking about software architecture A way/methodology, not a language Some languages are better for some paradigms than others Functional Programming (FP): Treats computation as the the evaluation of math functions and avoids changing-state and mutable data Passing data from function to function to get a result Functions are threatened as data (you can use them as parameters, return them, build functions from other functions, and build custom functions Have to be pure functions- not dependent on local/global states Good for modularity since each function will return the same output given the same input Object Oriented Programming (OOP): Based on the concept of \u201cobjects\u201d which may contain data in the form of fields/attributes and code in the form of procedures/methods Encapsulating data & behavior into objects that interact with other elements and can perform certain actions Read more here Procedural Programming (PP): Based on the concept of procedure call where procedures/routines/subroutines/functions simply contain a series of computational steps to be carried out \u2022 AKA inline programming and it takes a top-down approach \u2022 Writing a list of instructions to tell the computer what to do step by step Relies on procedures/routines Resource","title":"Programming Paradigms"},{"location":"general/paradigms/#what-is-a-programming-paradigm","text":"A style of programming/way of thinking about software architecture A way/methodology, not a language Some languages are better for some paradigms than others","title":"What is a Programming Paradigm?"},{"location":"general/paradigms/#functional-programming-fp","text":"Treats computation as the the evaluation of math functions and avoids changing-state and mutable data Passing data from function to function to get a result Functions are threatened as data (you can use them as parameters, return them, build functions from other functions, and build custom functions Have to be pure functions- not dependent on local/global states Good for modularity since each function will return the same output given the same input","title":"Functional Programming (FP):"},{"location":"general/paradigms/#object-oriented-programming-oop","text":"Based on the concept of \u201cobjects\u201d which may contain data in the form of fields/attributes and code in the form of procedures/methods Encapsulating data & behavior into objects that interact with other elements and can perform certain actions Read more here","title":"Object Oriented Programming (OOP):"},{"location":"general/paradigms/#procedural-programming-pp","text":"Based on the concept of procedure call where procedures/routines/subroutines/functions simply contain a series of computational steps to be carried out \u2022 AKA inline programming and it takes a top-down approach \u2022 Writing a list of instructions to tell the computer what to do step by step Relies on procedures/routines Resource","title":"Procedural Programming (PP):"},{"location":"general/python/","text":"Python Ternary Conditionals condition = True x = 1 if condition else 0 Number Formatting num1 = 1_000_000_000 num2 = 10_000_000 total = num1 + num2 print(f'{total:,}') #Uses f-string to format output w/ commas Context Managers Manage resources such as IO connections, threads, db connections, etc. by opening & closing resources automatically with open('test.txt','r') as f: file_contents = f.read() Enumerate Functions names = ['Bob','Steve','Jim'] for index,name in enumerate(names): print(index,name) for index,name in enumerate(names, start=1): #Can specify starting index value print(index,name) Zip Function Loops over n lists at once. When lists are different lengths, it stops at the end of the shortest list for name, hero, universe in zip(names, heroes, universes): print(name,hero) for value in zip(names, heroes, universes): print(value) #Value is a tuple of the results of the 3 lists Unpacking a,b = (1,2) print(a) #1 print(b) #2 c,_ = (4,5) #use underscore when you don't want to use a variable print(c) #4 x,y,*z = (1,2,3,5,6,7) print(x) #1 print(y) #2 print(z) #[3,5,6,7] x,y,*_, z = (1,2,3,4,6,7,) #ignores all values after 1 & 2 but until 7, which is stored in z Requests Library import requests url_params = {'page' : 2, 'count' : 25} r = requests.get(\"https://httpbin.org/get\", params=url_params) body = {'username' : 'corey', 'password' : 'testing'} r = requests.post(\"https://httpbin.org/post\", data=body, timeout=3) #include the timeout argument to Raise a ReadTimeout Error if the website does not respond in time r_dict = r.json() Environment Variables MacOS terminal: - export <var-name>=<var-value> (add new env var) - export <existing-var-name>=<var-value>:$<existing-var-name> (prepend values to an existing env var) - unset <var-name> (remove env var) os.environ acts like a python dictionary If you have other scripts updating the environment while your python script is running, calling os.environ again will not reflect the latest values since the mapping is only read when the python script is initially run. import os os.environ['DB_USER'] = str(123) # env vars must always be strings db_user = os.environ['DB_USER'] db_user = os.environ.get('DB_USER') # safe way of accessing potentially undefined env vars Memoization/Caching Examples calculate the nth term of the fibonacci sequence Basic implementation with dictionary fibonacci_cache = {} def fibonacci(n): if n in fibonacci_cache: return fibonacci_cache[n] elif n == 1 or n == 2: value = 1 else: value = fibonacci(n-1) + fibonacci(n-2) fibonacci_cache[n] = value return value Optimized implementation with function tools from functools import lru_cache @lru_cache(maxsize=1000) def fibonacci(n): if n == 1 or n ==2: return 1 else: return fibonacci(n-1)+fibonacci(n-2) Config Parser Documentation . Configuration file format: [section] option1 = value1 option2 = value2 Reading the configuration file: from configparser import ConfigParser parser = ConfigParser() parser.read('file.ini') if parser.has_section('database'): items = parser.items('database') Its good to store things that could change in the configuration file (e.g. endpoints, db logins/tables/sprocs) CSV Files import csv with open(file1, 'r'), open(file2, 'w') as f1, f2: csv_read = csv.reader(f1) csv_writer = csv.writer(f2) next(csv_read) # Skip header row for line in csv_reader: csv_writer.writerow([line[0],\"extra col\"]) Python Executable MacOS installs python 2.7 by default and should not be deleted /usr/bin/python and /usr/bin/python2 are symlinks to default install: System/Library/Frameworks/Python.framework/Versions/2.7/bin/python2.7 Python 3+ versions are installed in /usr/local/bin/python3 is a symlink to version 3.5 installed in /Library/Frameworks/Python.framework/Versions/3.5 by downloading python from internet /usr/local/bin/python3.9 is a symlink to version 3.9 installed in /usr/local/Cellar by homebrew (same goes for pip3.9 ) /usr/bin/python3 is the actual install of version 3.8. Note sure how it got there but it is currently looked at on the path after the other version of python3 in the local/bin so it is not found unless the version is being explicitly looked for All 3 versions of python3 are needed for ROS stuff so thats fun python3 -m module_name Searches the path for the module and excecutes its contents as the main module (Runs the specified module even if it isnt in the cwd) Note: find symlinks using ls -l","title":"Python"},{"location":"general/python/#python","text":"","title":"Python"},{"location":"general/python/#ternary-conditionals","text":"condition = True x = 1 if condition else 0","title":"Ternary Conditionals"},{"location":"general/python/#number-formatting","text":"num1 = 1_000_000_000 num2 = 10_000_000 total = num1 + num2 print(f'{total:,}') #Uses f-string to format output w/ commas","title":"Number Formatting"},{"location":"general/python/#context-managers","text":"Manage resources such as IO connections, threads, db connections, etc. by opening & closing resources automatically with open('test.txt','r') as f: file_contents = f.read()","title":"Context Managers"},{"location":"general/python/#enumerate-functions","text":"names = ['Bob','Steve','Jim'] for index,name in enumerate(names): print(index,name) for index,name in enumerate(names, start=1): #Can specify starting index value print(index,name)","title":"Enumerate Functions"},{"location":"general/python/#zip-function","text":"Loops over n lists at once. When lists are different lengths, it stops at the end of the shortest list for name, hero, universe in zip(names, heroes, universes): print(name,hero) for value in zip(names, heroes, universes): print(value) #Value is a tuple of the results of the 3 lists","title":"Zip Function"},{"location":"general/python/#unpacking","text":"a,b = (1,2) print(a) #1 print(b) #2 c,_ = (4,5) #use underscore when you don't want to use a variable print(c) #4 x,y,*z = (1,2,3,5,6,7) print(x) #1 print(y) #2 print(z) #[3,5,6,7] x,y,*_, z = (1,2,3,4,6,7,) #ignores all values after 1 & 2 but until 7, which is stored in z","title":"Unpacking"},{"location":"general/python/#requests-library","text":"import requests url_params = {'page' : 2, 'count' : 25} r = requests.get(\"https://httpbin.org/get\", params=url_params) body = {'username' : 'corey', 'password' : 'testing'} r = requests.post(\"https://httpbin.org/post\", data=body, timeout=3) #include the timeout argument to Raise a ReadTimeout Error if the website does not respond in time r_dict = r.json()","title":"Requests Library"},{"location":"general/python/#environment-variables","text":"MacOS terminal: - export <var-name>=<var-value> (add new env var) - export <existing-var-name>=<var-value>:$<existing-var-name> (prepend values to an existing env var) - unset <var-name> (remove env var) os.environ acts like a python dictionary If you have other scripts updating the environment while your python script is running, calling os.environ again will not reflect the latest values since the mapping is only read when the python script is initially run. import os os.environ['DB_USER'] = str(123) # env vars must always be strings db_user = os.environ['DB_USER'] db_user = os.environ.get('DB_USER') # safe way of accessing potentially undefined env vars","title":"Environment Variables"},{"location":"general/python/#memoizationcaching","text":"Examples calculate the nth term of the fibonacci sequence Basic implementation with dictionary fibonacci_cache = {} def fibonacci(n): if n in fibonacci_cache: return fibonacci_cache[n] elif n == 1 or n == 2: value = 1 else: value = fibonacci(n-1) + fibonacci(n-2) fibonacci_cache[n] = value return value Optimized implementation with function tools from functools import lru_cache @lru_cache(maxsize=1000) def fibonacci(n): if n == 1 or n ==2: return 1 else: return fibonacci(n-1)+fibonacci(n-2)","title":"Memoization/Caching"},{"location":"general/python/#config-parser","text":"Documentation . Configuration file format: [section] option1 = value1 option2 = value2 Reading the configuration file: from configparser import ConfigParser parser = ConfigParser() parser.read('file.ini') if parser.has_section('database'): items = parser.items('database') Its good to store things that could change in the configuration file (e.g. endpoints, db logins/tables/sprocs)","title":"Config Parser"},{"location":"general/python/#csv-files","text":"import csv with open(file1, 'r'), open(file2, 'w') as f1, f2: csv_read = csv.reader(f1) csv_writer = csv.writer(f2) next(csv_read) # Skip header row for line in csv_reader: csv_writer.writerow([line[0],\"extra col\"])","title":"CSV Files"},{"location":"general/python/#python-executable","text":"MacOS installs python 2.7 by default and should not be deleted /usr/bin/python and /usr/bin/python2 are symlinks to default install: System/Library/Frameworks/Python.framework/Versions/2.7/bin/python2.7 Python 3+ versions are installed in /usr/local/bin/python3 is a symlink to version 3.5 installed in /Library/Frameworks/Python.framework/Versions/3.5 by downloading python from internet /usr/local/bin/python3.9 is a symlink to version 3.9 installed in /usr/local/Cellar by homebrew (same goes for pip3.9 ) /usr/bin/python3 is the actual install of version 3.8. Note sure how it got there but it is currently looked at on the path after the other version of python3 in the local/bin so it is not found unless the version is being explicitly looked for All 3 versions of python3 are needed for ROS stuff so thats fun python3 -m module_name Searches the path for the module and excecutes its contents as the main module (Runs the specified module even if it isnt in the cwd) Note: find symlinks using ls -l","title":"Python Executable"},{"location":"general/regex/","text":"Regular expressions operate by moving character by character, from left to right, through a piece of text. When the regular expression finds a character that matches the first piece of the expression, it looks to find a continuous sequence of matching characters. Alternation is performed in regular expressions with the pipe symbol, | , allowing us to match either the characters preceding the | OR the characters after the | . Grouping , denoted with the open parenthesis ( and the closing parenthesis ) , lets us group parts of a regular expression together, and allows us to limit alternation to part of the regex. Character sets , denoted by a pair of brackets [] , let us match one character from a series of characters, allowing for matches with incorrect or different spellings. Negated Character Sets : at the front of a character set, the ^ negates the set, matching any character that is not stated. Thus the regex [^cat] will match any character that is not c , a , or t , and would completely match each character d , o or g . Wildcards . will match any single character (letter, number, symbol or whitespace) in a piece of text. We can use the escape character, \\ , to escape the wildcard functionality of the . and match an actual period. Ranges allow us to specify a range of characters in which we can make a match without having to type out each individual character. The - character allows us to specify that we are interested in matching a range of characters. Shorthand Character Classes represent common ranges and make writing regular expressions much simpler: \\w : the \u201cword character\u201d class represents the regex range [A-Za-z0-9_] , and it matches a single uppercase character, lowercase character, digit or underscore \\d : the \u201cdigit character\u201d class represents the regex range [0-9] , and it matches a single digit character \\s : the \u201cwhitespace character\u201d class represents the regex range [ \\t\\r\\n\\f\\v] , matching a single space, tab, carriage return, line break, form feed, or vertical tab Negated Character Classes are shorthands that match any character not in the regular shorthand classes: \\W : the \u201cnon-word character\u201d class represents the regex range [^A-Za-z0-9_] , matching any character that is not included in the range represented by \\w \\D : the \u201cnon-digit character\u201d class represents the regex range [^0-9] , matching any character that is not included in the range represented by \\d \\S : the \u201cnon-whitespace character\u201d class represents the regex range [^ \\t\\r\\n\\f\\v] , matching any character that is not included in the range represented by \\s Fixed quantifiers , denoted with curly braces {} , let us indicate the exact quantity of a character we wish to match, or allow us to provide a quantity range to match on. \\w{3} will match exactly 3 word characters \\w{4,7} will match at minimum 4 word characters and at maximum 7 word characters An important note is that quantifiers are considered to be greedy . This means that they will match the greatest quantity of characters they possibly can. For example, the regex mo{2,4} will match the text moooo in the string moooo , and not return a match of moo , or mooo . Optional quantifiers , indicated by the question mark ? , allow us to indicate a character in a regex is optional, or can appear either 0 times or 1 time. The ? only applies to the character/grouping directly before it. Use the escape character in your regex in order to match a question mark ? in a piece of text. The Kleene star , denoted with the asterisk * , is also a quantifier, and matches the preceding character 0 or more times. This means that the character doesn\u2019t need to appear, can appear once, or can appear many many times. The Kleene plus , denoted by the plus + matches the preceding character 1 or more times. The anchors hat ^ and dollar sign $ are used to match text at the start and the end of a string, respectively. The regex ^Monkeys: my mortal enemy$ will completely match the text Monkeys: my mortal enemy but not match Spider Monkeys: my mortal enemy in the wild Summary: Regular expressions are special sequences of characters that describe a pattern of text that is to be matched We can use literals to match the exact characters that we desire Alternation , using the pipe symbol | , allows us to match the text preceding or following the | Character sets , denoted by a pair of brackets [] , let us match one character from a series of characters Wildcards , represented by the period or dot . , will match any single character (letter, number, symbol or whitespace) Ranges allow us to specify a range of characters in which we can make a match Shorthand character classes like \\w , \\d and \\s represent the ranges representing word characters, digit characters, and whitespace characters, respectively Groupings , denoted with parentheses () , group parts of a regular expression together, and allows us to limit alternation to part of a regex Fixed quantifiers , represented with curly braces {} , let us indicate the exact quantity or a range of quantity of a character we wish to match Optional quantifiers , indicated by the question mark ? , allow us to indicate a character in a regex is optional, or can appear either 0 times or 1 time The Kleene star , denoted with the asterisk * , is a quantifier that matches the preceding character 0 or more times The Kleene plus , denoted by the plus + , matches the preceding character 1 or more times The anchor symbols hat ^ and dollar sign $ are used to match text at the start and end of a string, respectively","title":"Regex"},{"location":"general/regex/#summary","text":"Regular expressions are special sequences of characters that describe a pattern of text that is to be matched We can use literals to match the exact characters that we desire Alternation , using the pipe symbol | , allows us to match the text preceding or following the | Character sets , denoted by a pair of brackets [] , let us match one character from a series of characters Wildcards , represented by the period or dot . , will match any single character (letter, number, symbol or whitespace) Ranges allow us to specify a range of characters in which we can make a match Shorthand character classes like \\w , \\d and \\s represent the ranges representing word characters, digit characters, and whitespace characters, respectively Groupings , denoted with parentheses () , group parts of a regular expression together, and allows us to limit alternation to part of a regex Fixed quantifiers , represented with curly braces {} , let us indicate the exact quantity or a range of quantity of a character we wish to match Optional quantifiers , indicated by the question mark ? , allow us to indicate a character in a regex is optional, or can appear either 0 times or 1 time The Kleene star , denoted with the asterisk * , is a quantifier that matches the preceding character 0 or more times The Kleene plus , denoted by the plus + , matches the preceding character 1 or more times The anchor symbols hat ^ and dollar sign $ are used to match text at the start and end of a string, respectively","title":"Summary:"},{"location":"general/swe-notes/","text":"Software Engineering Notebook UML Class Diagram Visual diagram used to demonstrate classes, their attributes/functions, and the relationships between classes Useful to start one before a large project to see how all the components interact Youtube Tutorial Lucid Chart (Online software used by numerous Fortune 500 companies for creating visual workspaces w/ things like UML diagrams) Class Construction Declare all fields as private/protected whenever possible Use getter and setter functions to access and update class fields Initialize the fields in the constructor Code Readability Readability and maintainability separate coders from good coders Focus on being able to read and understand parts of parts of code (e.g. modules/functions) without having to read entire rest of codebase Code should be Intuitive and self-documenting Readability > Cleverness/Shortness If you write the code as clever as possible, you will not be smart enough to debug it Consistency in style (e.g. spacing, braces) Commenting/Documentation Learning to write good comments is a skill Any good developer can figure out what your code does so your comments should explain why it does it that way Comment on why you made the decisions you did in your code Software Design Patterns Use encapsulation in order to separate concerns (i.e. possible points of breakdown in locally important assumptions such as object types) Try to limit managing global states (e.g. updating/referencing) since that can easily get messy, complicated, and buggy Clarity of a codebase greatly improves when pure functions that access no external state are used Functional languages like Haskell do this really well Don\u2019t switch between programming designs (e.g. pub/sub, actors, MVC) in connected parts of a codebase Create Data Abstraction Layers Ex: Don\u2019t have queries for your database in your application code. Instead create a separate library between the database and application that handles all the queries and provides easy to use getter functions like load_users(). Creates consistent styles in queries Limits the number of places to change queries if the DB schema changes Building a Software Stack Don\u2019t reinvent the wheel when not necessary Reliance on 3rd-party/open source software does leave you vulnerable to their security issues and makes you reliant on other people\u2019s maintenance of the dependencies Choose Appropriate Database: SQL: Postgres / MySQL / MariaDB / MemSQL / Amazon RDS Key Value Stores: Redis / Memcache / Riak NoSQL: MongoDB / Cassandra Hosted DBs: AWS RDS / DynamoDB / AppEngine Datastore Heavy Lifting: Amazon MR / Hadoop (Hive/Pig) / Cloudera / Google Big Query Debugging Come up w/ a hypothesis and test it (repeat until you fix the bug) Think like a scientist when debugging Record hypothesis and result Reproduce the bug locally rather than on a server (if convenient) Once you can fix it locally (which is faster & easier) you can change it on the server version Read the source code carefully and make minor alterations according to your hypothesis Use debuggers instead of messy print statements Problem Solving Define the problem Brainstorm (no idea is a bad idea) Pseudo-Code (don\u2019t worry about syntax- get the ideas down) Whiteboarding/writing is useful Implement (test as you go and make sure each component works before moving on) Avoid building out a whole solution w/o testing any of the parts Optimize efficiency (Go back and try to condense code, make more efficient, etc.) Time, memory, etc. Don't optimize too soon or overoptimize something that is fine Transition solution to another language if learning a new language General Tips You are responsible for code quality Use meaningful names Write code that expresses intent Code should speak for itself (Less comments = Less maintenance) Leave the code better than you found it Single-responsibility code Function does one thing well Less arguments = better function Tests! (Test Driven Development) Work on the big picture skeleton for the program and then fill in the details later Interface first, implementation later Independent components that can be used in different places Master your craft Create a minimum viable product (MVP) with the base functionality and then iterate by adding more features Notes on SWE Not an industry, it\u2019s a skill achieved with lots of practice Applicable to all industries available today (i.e. software runs everything) Solving problems is an art form-- you get better with lifelong practice Resources Readability & Software Design Practices Clean Code (Book) Commenting Less REST API Design","title":"Software Engineering Notebook"},{"location":"general/swe-notes/#software-engineering-notebook","text":"","title":"Software Engineering Notebook"},{"location":"general/swe-notes/#uml-class-diagram","text":"Visual diagram used to demonstrate classes, their attributes/functions, and the relationships between classes Useful to start one before a large project to see how all the components interact Youtube Tutorial Lucid Chart (Online software used by numerous Fortune 500 companies for creating visual workspaces w/ things like UML diagrams)","title":"UML Class Diagram"},{"location":"general/swe-notes/#class-construction","text":"Declare all fields as private/protected whenever possible Use getter and setter functions to access and update class fields Initialize the fields in the constructor","title":"Class Construction"},{"location":"general/swe-notes/#code-readability","text":"Readability and maintainability separate coders from good coders Focus on being able to read and understand parts of parts of code (e.g. modules/functions) without having to read entire rest of codebase Code should be Intuitive and self-documenting Readability > Cleverness/Shortness If you write the code as clever as possible, you will not be smart enough to debug it Consistency in style (e.g. spacing, braces)","title":"Code Readability"},{"location":"general/swe-notes/#commentingdocumentation","text":"Learning to write good comments is a skill Any good developer can figure out what your code does so your comments should explain why it does it that way Comment on why you made the decisions you did in your code","title":"Commenting/Documentation"},{"location":"general/swe-notes/#software-design-patterns","text":"Use encapsulation in order to separate concerns (i.e. possible points of breakdown in locally important assumptions such as object types) Try to limit managing global states (e.g. updating/referencing) since that can easily get messy, complicated, and buggy Clarity of a codebase greatly improves when pure functions that access no external state are used Functional languages like Haskell do this really well Don\u2019t switch between programming designs (e.g. pub/sub, actors, MVC) in connected parts of a codebase Create Data Abstraction Layers Ex: Don\u2019t have queries for your database in your application code. Instead create a separate library between the database and application that handles all the queries and provides easy to use getter functions like load_users(). Creates consistent styles in queries Limits the number of places to change queries if the DB schema changes","title":"Software Design Patterns"},{"location":"general/swe-notes/#building-a-software-stack","text":"Don\u2019t reinvent the wheel when not necessary Reliance on 3rd-party/open source software does leave you vulnerable to their security issues and makes you reliant on other people\u2019s maintenance of the dependencies Choose Appropriate Database: SQL: Postgres / MySQL / MariaDB / MemSQL / Amazon RDS Key Value Stores: Redis / Memcache / Riak NoSQL: MongoDB / Cassandra Hosted DBs: AWS RDS / DynamoDB / AppEngine Datastore Heavy Lifting: Amazon MR / Hadoop (Hive/Pig) / Cloudera / Google Big Query","title":"Building a Software Stack"},{"location":"general/swe-notes/#debugging","text":"Come up w/ a hypothesis and test it (repeat until you fix the bug) Think like a scientist when debugging Record hypothesis and result Reproduce the bug locally rather than on a server (if convenient) Once you can fix it locally (which is faster & easier) you can change it on the server version Read the source code carefully and make minor alterations according to your hypothesis Use debuggers instead of messy print statements","title":"Debugging"},{"location":"general/swe-notes/#problem-solving","text":"Define the problem Brainstorm (no idea is a bad idea) Pseudo-Code (don\u2019t worry about syntax- get the ideas down) Whiteboarding/writing is useful Implement (test as you go and make sure each component works before moving on) Avoid building out a whole solution w/o testing any of the parts Optimize efficiency (Go back and try to condense code, make more efficient, etc.) Time, memory, etc. Don't optimize too soon or overoptimize something that is fine Transition solution to another language if learning a new language","title":"Problem Solving"},{"location":"general/swe-notes/#general-tips","text":"You are responsible for code quality Use meaningful names Write code that expresses intent Code should speak for itself (Less comments = Less maintenance) Leave the code better than you found it Single-responsibility code Function does one thing well Less arguments = better function Tests! (Test Driven Development) Work on the big picture skeleton for the program and then fill in the details later Interface first, implementation later Independent components that can be used in different places Master your craft Create a minimum viable product (MVP) with the base functionality and then iterate by adding more features","title":"General Tips"},{"location":"general/swe-notes/#notes-on-swe","text":"Not an industry, it\u2019s a skill achieved with lots of practice Applicable to all industries available today (i.e. software runs everything) Solving problems is an art form-- you get better with lifelong practice","title":"Notes on SWE"},{"location":"general/swe-notes/#resources","text":"Readability & Software Design Practices Clean Code (Book) Commenting Less REST API Design","title":"Resources"},{"location":"general/terminal-cmds/","text":"Terminal Commands (Mac) Navigation: cd {/path/to/folder} : changes directory to specified path cd / : goes to root directory cd ~ : goes to user directory ls : lists all files/folders in the current working directory pwd : prints the path to the current working directory| Creating & Deleting: mkdir {foldername} : makes a folder with the specified nam rm {filename} : removes the specified file rm -r {foldername} : removes the specified folder recursively touch {filename} : creates the specified file| mv {filename} {new filename} : renames the file/folder to the 2nd name Opening Files/Folders: open {filename} : opens the file with the default program open {filename} -a \"{program name}\" : opens the file in the specified application open . : opens the current folder in finder open . -a \"{program name}\" opens the folder in the specified application Terminal Commands Different in Windows: dir - list files echo > {filename} - create an empty file del {filename} - remove a file rmdir {directory name} - remove a directory and all files within rename {filename} {new filename} - rename a file or folder start {filename} - open file in default program start . - open current directory cls - clear the terminal screen Vim Commands Command Function i insert/typing mode esc leave insert mode :w save additions :wq save & quit :q! quit & discard changes Key Movement w front of next word b front of previous word 0 start of line $ end of line g last line a append to final line","title":"Terminal cmds"},{"location":"general/terminal-cmds/#terminal-commands-mac","text":"","title":"Terminal Commands (Mac)"},{"location":"general/terminal-cmds/#navigation","text":"cd {/path/to/folder} : changes directory to specified path cd / : goes to root directory cd ~ : goes to user directory ls : lists all files/folders in the current working directory pwd : prints the path to the current working directory|","title":"Navigation:"},{"location":"general/terminal-cmds/#creating-deleting","text":"mkdir {foldername} : makes a folder with the specified nam rm {filename} : removes the specified file rm -r {foldername} : removes the specified folder recursively touch {filename} : creates the specified file| mv {filename} {new filename} : renames the file/folder to the 2nd name","title":"Creating &amp; Deleting:"},{"location":"general/terminal-cmds/#opening-filesfolders","text":"open {filename} : opens the file with the default program open {filename} -a \"{program name}\" : opens the file in the specified application open . : opens the current folder in finder open . -a \"{program name}\" opens the folder in the specified application","title":"Opening Files/Folders:"},{"location":"general/terminal-cmds/#terminal-commands-different-in-windows","text":"dir - list files echo > {filename} - create an empty file del {filename} - remove a file rmdir {directory name} - remove a directory and all files within rename {filename} {new filename} - rename a file or folder start {filename} - open file in default program start . - open current directory cls - clear the terminal screen","title":"Terminal Commands Different in Windows:"},{"location":"general/terminal-cmds/#vim-commands","text":"Command Function i insert/typing mode esc leave insert mode :w save additions :wq save & quit :q! quit & discard changes Key Movement w front of next word b front of previous word 0 start of line $ end of line g last line a append to final line","title":"Vim Commands"},{"location":"math_science/brain/","text":"The average adult brain weighs about 3 lbs which is roughly 2% of total body weight. However it requires 20% of the total amount of energy our bodies spend in a day of no activity. This means it takes roughly 13 watts to power the brain. To put things in perspective, this is 1/5 of the power required by a standard 60 watt lightbulb. When compared to even the most impressive computers-- IBM's Watson which runs on a supercomputer that requires around 1,000 watts-- the brains ability computational ability compared to power consumption is remarkable. The Neuron Our brain is comprised of an estimated 100 billion neurons that operate together in order to produce behavior by transmitting and integrating information at the individual level. Each neuron is connected to roughly 50,000 others. A neuron is comprised of 3 main parts: 1. Dendrites- \"input\" side that receives signals from many other neurons 2. Cell Body- contains the nucleus and all elements needed for normal metabolic activities of these cells 3. Axon- \"output\" side that transmitts neural impulses to other neurons There are many varities of neurons that range in size from 5 microns in diameter to 100 microns-- the size of a human hair in diameter. The 3 main types of neurons are the following: Efferent Neurons- carry information outward from the central nervous system Afferent Neurons- carry information from the external world and body's internal environment inward to the central nervous system Interneurons- carry information from one neuron to another and comprise 99% of neurons in the brain How are signals transferrred? The science behind how electrical signals are transferred in the brain involves some physics and biology. Cells have a higher concentration of positive ions on the outside than the inside which creates a higher potential on the outside. The V_{out} = 0 mV while V_{in} = -70 mV . At the peak of the potential inside the nerve cell, the positive charges begin moving down the axon in order to maximize the distance between positive ions. This is the start of an electrical signal being transmitted. The myelin sheath which has a high resisitvity and covers the axon keeps the positive ions trapped, preventing the signal from disappating. Gaps in the myelin sheath called nodes of ranvier contain voltage gated sodium pumps that repeat the same process as above with the action potential when the electrical charge signal, helping to push the electrical signal further down the axon. The myelin sheath combined with nodes of ranvier allow for the electrical signal to be transmitted at very high speeds. These transmissions of electrical signals form the basis for all activity and computation done by the brain. While there are always things to further understand such as why sodium pumps work or the quantum mechanics behind the movement of electrons, we use layers of abstraction to allow us to build up understanding of certain aspects without having to understand every single thing that makes something occur. Abstraction is the key to making things understandable to humans and is critical in many fields outside of CS/EE in areas such as bio where complex phenomena can be studied at varying levels of abstraction in order to gain different insights. Its pretty meta when you think about how a brain is creating these layers of abstraction just so it can think about how itself works and begin to have an understanding of what it means to think. Brain Diseases Multiple Sclerosis (MS) is a disease where damage is done to the myelin sheaths in the brain, making it difficult for signals to travel, thus causing a breakdown in many critical functions such as muscle control. Sources PSY-PC 1205 PHYS 1602 Brain Power","title":"The Brain"},{"location":"math_science/brain/#the-neuron","text":"Our brain is comprised of an estimated 100 billion neurons that operate together in order to produce behavior by transmitting and integrating information at the individual level. Each neuron is connected to roughly 50,000 others. A neuron is comprised of 3 main parts: 1. Dendrites- \"input\" side that receives signals from many other neurons 2. Cell Body- contains the nucleus and all elements needed for normal metabolic activities of these cells 3. Axon- \"output\" side that transmitts neural impulses to other neurons There are many varities of neurons that range in size from 5 microns in diameter to 100 microns-- the size of a human hair in diameter. The 3 main types of neurons are the following: Efferent Neurons- carry information outward from the central nervous system Afferent Neurons- carry information from the external world and body's internal environment inward to the central nervous system Interneurons- carry information from one neuron to another and comprise 99% of neurons in the brain","title":"The Neuron"},{"location":"math_science/brain/#how-are-signals-transferrred","text":"The science behind how electrical signals are transferred in the brain involves some physics and biology. Cells have a higher concentration of positive ions on the outside than the inside which creates a higher potential on the outside. The V_{out} = 0 mV while V_{in} = -70 mV . At the peak of the potential inside the nerve cell, the positive charges begin moving down the axon in order to maximize the distance between positive ions. This is the start of an electrical signal being transmitted. The myelin sheath which has a high resisitvity and covers the axon keeps the positive ions trapped, preventing the signal from disappating. Gaps in the myelin sheath called nodes of ranvier contain voltage gated sodium pumps that repeat the same process as above with the action potential when the electrical charge signal, helping to push the electrical signal further down the axon. The myelin sheath combined with nodes of ranvier allow for the electrical signal to be transmitted at very high speeds. These transmissions of electrical signals form the basis for all activity and computation done by the brain. While there are always things to further understand such as why sodium pumps work or the quantum mechanics behind the movement of electrons, we use layers of abstraction to allow us to build up understanding of certain aspects without having to understand every single thing that makes something occur. Abstraction is the key to making things understandable to humans and is critical in many fields outside of CS/EE in areas such as bio where complex phenomena can be studied at varying levels of abstraction in order to gain different insights. Its pretty meta when you think about how a brain is creating these layers of abstraction just so it can think about how itself works and begin to have an understanding of what it means to think.","title":"How are signals transferrred?"},{"location":"math_science/brain/#brain-diseases","text":"Multiple Sclerosis (MS) is a disease where damage is done to the myelin sheaths in the brain, making it difficult for signals to travel, thus causing a breakdown in many critical functions such as muscle control.","title":"Brain Diseases"},{"location":"math_science/brain/#sources","text":"PSY-PC 1205 PHYS 1602 Brain Power","title":"Sources"},{"location":"math_science/physics/ch25/","text":"Current Current is the movement of net charges. More formally it is defined as the rate at which net charge flows past any section of a conductor. The unit of current is the ampere (1 A = 1 C/sec) Current density is the amount of net charge flowing through a unit area. J = nev_d The relation between current density and current is intuitively going to be the sum of the current density at each point times the area of each point. This can be expressed in general using a surface integral: I = \\int \\int J \\cdot dA If the current density J is uniform and the area A is flat, we get a simplified I = J \\cdot A which for simple wires where the angle between the flow and the area is 0, yields the equation I = JA . Resistance Voltage and current are observed to be proportional in most materials. The constant that relates the voltage and current for a given material is called the resistance R : V = RI . The resistance can be thought of as a measure of how difficult it is for current to flow. When free electrons are flowing through a material, they will inevitably collide with the nuclei of the materials' atoms. Certain materials will have nuclei arrangmenets that will result in more collisions, corresponding to lower current flow and a higher resistance value. This relationship of V = RI is known as Ohm's law after being discovered by George Ohm in 1827. Materials that are observed to follow Ohm's law are known as ohmic materials while ones that do not are known as nonohmic materials. Resistance has numerous applications such as being used to design circuit boards as well as its use in the myelin sheaths of our nerves to transmit electrical signals. Factors affecting Resistance Resistance depends on the material and details/geometry of the sample . Resistivity is the resistance of a unit cube of a given material and depends on the material only. \\rho = \\frac{E}{J} Note that conductivtiy is simply the inverse of resistivity. Resistivity and thus resistance, depends on temperature. Higher temperatures will increase the resistivity and thus increase the resistance and vice versa.","title":"Current & Resistance"},{"location":"math_science/physics/ch25/#current","text":"Current is the movement of net charges. More formally it is defined as the rate at which net charge flows past any section of a conductor. The unit of current is the ampere (1 A = 1 C/sec) Current density is the amount of net charge flowing through a unit area. J = nev_d The relation between current density and current is intuitively going to be the sum of the current density at each point times the area of each point. This can be expressed in general using a surface integral: I = \\int \\int J \\cdot dA If the current density J is uniform and the area A is flat, we get a simplified I = J \\cdot A which for simple wires where the angle between the flow and the area is 0, yields the equation I = JA .","title":"Current"},{"location":"math_science/physics/ch25/#resistance","text":"Voltage and current are observed to be proportional in most materials. The constant that relates the voltage and current for a given material is called the resistance R : V = RI . The resistance can be thought of as a measure of how difficult it is for current to flow. When free electrons are flowing through a material, they will inevitably collide with the nuclei of the materials' atoms. Certain materials will have nuclei arrangmenets that will result in more collisions, corresponding to lower current flow and a higher resistance value. This relationship of V = RI is known as Ohm's law after being discovered by George Ohm in 1827. Materials that are observed to follow Ohm's law are known as ohmic materials while ones that do not are known as nonohmic materials. Resistance has numerous applications such as being used to design circuit boards as well as its use in the myelin sheaths of our nerves to transmit electrical signals.","title":"Resistance"},{"location":"math_science/physics/ch25/#factors-affecting-resistance","text":"Resistance depends on the material and details/geometry of the sample . Resistivity is the resistance of a unit cube of a given material and depends on the material only. \\rho = \\frac{E}{J} Note that conductivtiy is simply the inverse of resistivity. Resistivity and thus resistance, depends on temperature. Higher temperatures will increase the resistivity and thus increase the resistance and vice versa.","title":"Factors affecting Resistance"},{"location":"math_science/prob_stats/crvs/","text":"Continuous Random Variables A CRV X satisifes: 1) Possible values of X make up an interval or union of disjoint intervals 2) P(X = c) = 0) for any c that is a possible value of X Probability Density Function DEF: Let X be a CRV. Then a probability density function of X is a function f s.t. P(a \\leq X \\leq b) = \\int_a^b f(x) dx This can be interpreted as the probability that X takes on a value in the interval [a,b] is the area above the interval and under the graph of the density function. Properties of pdfs: 1) f(x) \\geq 0 for all x 2) \\int_{-\\infty}^\\infty f(x)dx = 1 (area under the entire graph of f(x) ) Cumulative Distribution Function F(x) = P(X \\leq x) = \\int_{-\\infty}^x f(y) dy This can be interpreted as the area under the density curve to the left of x . Propositions P(x > a) = 1 - F(a) P(a \\leq X \\leq b) = F(b) - F(a) The (100p) th percentile of a CRV X : p = F[n(p)] = \\int_{-\\infty}^{n(p)} f(y) dy where n(p) is the value on the measurement axis s.t. 100p % of the area under the density curve is to left of n(p) Ex: n(.75) stands for the 75% percentile where 75% of the area is to the left of n(.75) PDFs and CDFs PDFs measure how much the mass changes per unit of length (aka contribution to mass per unit length) CDFs measure the total mass up to a pt x (achieves this my taking the integral on the desired interval to get the mass of that interval) F(x) = \\int_{-\\infty}^x f(y) dy In the cdf's formula, the dy is a tiny length so f(y)dy is the contribution of mass by the point y so integrating (summing over an uncountable interval) the interval gives the total mass of probability. To get the cdf from the pdf, we integrate the pdf over the desired interval. To get the pdf from the cdf, we take the derivative of the cdf and evaluate it at the desired point. At every x which F'(x) exists, F'(x) = f(x) Variance \\sigma_X^2 = V(X)= \\int_{-\\infty}^\\infty (x - \\mu)^2 f(x) dx = E[(X - \\mu)^2] V(X) = E(X^2) - [E(X)]^2 V(aX + b) = a^2\\sigma_X^2 Expected Value E(aX + b) = aE(X) + b If X is largely concentrated on an interval of values close to \\mu , the mean value and variance of Y = h(X) can be approximated using the assumption that h(x) is differentiable. Approximating E[h(X)] \\approx h(\\mu) V[h(X)] \\approx [h'(\\mu)]^2 \\sigma^2 These follow from approximating h(X) using a first order taylor series expansion about (\\mu,h(\\mu)) : Y = h(X) \\approx h(\\mu) + h'(\\mu)(X - \\mu) Moment Generating Functions M_X(t) = E(e^{tX}) = \\int_{-\\infty}^{\\infty} e^{tx}f(x)dx Properties: M_X(0) = E(e^0) = \\int_{-\\infty}^{\\infty} e^{0x}(fx)dx = \\int_{-\\infty}^{\\infty} f(x)dx = 1 Let Y = aX +b . Then M_Y(t) = e^{bt}M_X(at) .","title":"Continuous Random Variables"},{"location":"math_science/prob_stats/crvs/#continuous-random-variables","text":"A CRV X satisifes: 1) Possible values of X make up an interval or union of disjoint intervals 2) P(X = c) = 0) for any c that is a possible value of X","title":"Continuous Random Variables"},{"location":"math_science/prob_stats/crvs/#probability-density-function","text":"DEF: Let X be a CRV. Then a probability density function of X is a function f s.t. P(a \\leq X \\leq b) = \\int_a^b f(x) dx This can be interpreted as the probability that X takes on a value in the interval [a,b] is the area above the interval and under the graph of the density function. Properties of pdfs: 1) f(x) \\geq 0 for all x 2) \\int_{-\\infty}^\\infty f(x)dx = 1 (area under the entire graph of f(x) )","title":"Probability Density Function"},{"location":"math_science/prob_stats/crvs/#cumulative-distribution-function","text":"F(x) = P(X \\leq x) = \\int_{-\\infty}^x f(y) dy This can be interpreted as the area under the density curve to the left of x .","title":"Cumulative Distribution Function"},{"location":"math_science/prob_stats/crvs/#propositions","text":"P(x > a) = 1 - F(a) P(a \\leq X \\leq b) = F(b) - F(a) The (100p) th percentile of a CRV X : p = F[n(p)] = \\int_{-\\infty}^{n(p)} f(y) dy where n(p) is the value on the measurement axis s.t. 100p % of the area under the density curve is to left of n(p) Ex: n(.75) stands for the 75% percentile where 75% of the area is to the left of n(.75)","title":"Propositions"},{"location":"math_science/prob_stats/crvs/#pdfs-and-cdfs","text":"PDFs measure how much the mass changes per unit of length (aka contribution to mass per unit length) CDFs measure the total mass up to a pt x (achieves this my taking the integral on the desired interval to get the mass of that interval) F(x) = \\int_{-\\infty}^x f(y) dy In the cdf's formula, the dy is a tiny length so f(y)dy is the contribution of mass by the point y so integrating (summing over an uncountable interval) the interval gives the total mass of probability. To get the cdf from the pdf, we integrate the pdf over the desired interval. To get the pdf from the cdf, we take the derivative of the cdf and evaluate it at the desired point. At every x which F'(x) exists, F'(x) = f(x)","title":"PDFs and CDFs"},{"location":"math_science/prob_stats/crvs/#variance","text":"\\sigma_X^2 = V(X)= \\int_{-\\infty}^\\infty (x - \\mu)^2 f(x) dx = E[(X - \\mu)^2] V(X) = E(X^2) - [E(X)]^2 V(aX + b) = a^2\\sigma_X^2","title":"Variance"},{"location":"math_science/prob_stats/crvs/#expected-value","text":"E(aX + b) = aE(X) + b If X is largely concentrated on an interval of values close to \\mu , the mean value and variance of Y = h(X) can be approximated using the assumption that h(x) is differentiable.","title":"Expected Value"},{"location":"math_science/prob_stats/crvs/#approximating","text":"E[h(X)] \\approx h(\\mu) V[h(X)] \\approx [h'(\\mu)]^2 \\sigma^2 These follow from approximating h(X) using a first order taylor series expansion about (\\mu,h(\\mu)) : Y = h(X) \\approx h(\\mu) + h'(\\mu)(X - \\mu)","title":"Approximating"},{"location":"math_science/prob_stats/crvs/#moment-generating-functions","text":"M_X(t) = E(e^{tX}) = \\int_{-\\infty}^{\\infty} e^{tx}f(x)dx Properties: M_X(0) = E(e^0) = \\int_{-\\infty}^{\\infty} e^{0x}(fx)dx = \\int_{-\\infty}^{\\infty} f(x)dx = 1 Let Y = aX +b . Then M_Y(t) = e^{bt}M_X(at) .","title":"Moment Generating Functions"},{"location":"math_science/prob_stats/joint-distributions/","text":"Joint Probability Distributions Many problems involves several random variables, thus it is useful to have models for the joint behavior of several random variables, especially the case where the variables are independent of each other. Joint PMF for 2 DRVs A single pmf for a DRV X specifies the amount of mass for each possible value of X . The joint pmf of DRVs X and Y describes the amount of mass for each possible pair of values (x,y) . Let X and Y be two DRVs defined on sample space S of an experiment: p(x,y) = P(X = x \\cap Y = y) = \\sum_x sum_y p(x,y) The marginal pmfs of X and Y: p_X(x) = \\sum_y p(x,y) p_Y(y) = \\sum_x p(x,y) This makes sense since order to get the probability of a certain value of x, we take its probability as the sum over all possible y values. The marginal pmfs are useful for computing probabilites of events involving only one of the RVs. Joint PDF for 2 CRVs A single pdf for a CRV X specifies the amount of mass per unit length for each possible value of X on an interval/set. A joint pdf of CRVs X and Y specifies the amount of mass per unit area for each possible pair of values (x,y) . Let X and Y be two CRVs and A a two-dimensional set. P[(X,Y) \\in A] = \\int_A \\int f(x,y)dx dy Then f(x,y) is the joint pdf with properties: 1) f(x,y) \\geq 0 2) \\int_{-\\infty}^\\infty \\int_{-\\infty}^\\infty f(x,y) dx dy = 1 If A is a two-dimensional rectangle: P(a \\leq X \\leq b, c \\leq Y \\leq d) = \\int_a^b \\int_c^d f(x,y)dy dx The marginal pdfs for X and Y : f_X(x) = \\int_{-\\infty}^{\\infty} f(x,y) dy f_Y(y) = \\int_{-\\infty}^{\\infty} f(x,y) dx Independence of 2 RV DEF: Two RVs X and Y are independent if \\forall (x,y) p(x,y) = p_X(x)*p_Y(y) for DRVs f(x,y) = f_X(x)*f_Y(y) for CRVs Independence of n RV Def: x_1 ... x_n are independent RV if (for any subset a_1 to a_r ) for DRV P(x_{a_1}, ..., x_{a_r}) = P(x_{a_1}) * ... *P(x_{a_r}) for CRV f(x_{a_1}, ..., x_{a_r}) = f(x_{a_1}) * ... *f(x_{a_r}) Multinomial Distribution Model: n independent trials with replacement with r possible outcomes each. P_i = prob of getting ith outcome i = 1, ..., r . X_i = # times the ith outcome appears The jpmf of X_1 ,... X_r has a multinomial distribution. P(X_1, \\cdots , X_r) = \\frac{n!}{X_1!X_2! \\cdots X_r!}P_1^{X_1}P_2^{X_2} \\cdots P_r^{X_r} Divide by the number of permutations of each element to remove permutations from the total number of ways the elements can be arranged/ Expected Value for Functions of 2 RV X, Y are RV and Z = h(X,Y) . Remeber that the expected value can be thought of as a weighted average so the same idea extends to functions of 2 RV: DRV: E(Z) = \\sum_X \\sum_Y h(X,Y)P(X,Y) CRV: E(Z) = \\int_{-\\infin}^{\\infin}\\int_{-\\infin}^{\\infin} h(x,y) dy dx Note: You can change the order of summation/integration when the series is convergent (i dont really understand why) Propositions: 1) E(aX + Y) = aE(X) + E(Y) 2) If X,Y are independent, then E(X,Y) = E(X)E(Y) A counterexample s can be found such that the reverse of 2) does not hold meaning E(X,Y) = E(X)E(Y) does not imply independence of X and Y . Proof of 1) \\begin{aligned} E(aX+Y) &= \\sum_X \\sum_Y (aX+Y)P(X,Y) \\\\ &= a \\sum_X \\sum_Y X P(X,Y) + \\sum_X \\sum_Y YP(X,Y) \\\\ &= a \\sum_X X \\sum_Y P(X,Y) + \\sum_Y Y \\sum_X P(X,Y) \\\\ &= a \\sum_X X \\sum_Y P_X(X) + \\sum_Y Y \\sum_X P_Y(Y) \\\\ &= aE(X) + E(Y) \\end{aligned} ## Covariance DEF: X,Y are RV. Then Cov(X,Y) = E((x- \\mu_x)(Y-\\mu_y)) = E(X,Y) - E(X)E(Y) Interpretations Covariance measures how much X and Y are spread since Cov(X,X) = \\sigma^2 How much are X and Y related How much X and Y fail to be independent Cov(X,Y) = 0 does not imply independence as demonstrated by the counterexample to proposition 2 above. How linear is the relation between X and Y Examples The leftmost graph reprsents X and Y variables highly related in an inversely proportional way meaning when X increases, Y decreases and when X decresases, Y increases. The rightmost graph represents X and Y variables highly related in a directly proprtional way. Properties Cov(aX,Z) = aCov(X,Z) This implies Cov(aX,aX) = a^2Cov(X,X) . Cov(aX + bY, Z) = aCov(X,Z) + bCov(Y,Z) Correlation DEF: X and Y are random vars. Corr(X,Y) = \\delta_{x,y} = \\frac{Cov(X,Y)}{\\sigma_x \\sigma_y} Properties: 1) a,c > 0 or a, c <0 implies Corr(aX+b, cY+d) = Corr(X,Y) 2) -1 \\leq Corr(X,Y) \\leq 1 3) Corr(X,Y) = \\pm 1 iff Y = aX +b for some a \\neq 0 Correlation is unrelated to the value of the slope. Simply means when it is one, the slope is positive/increasing. WHen it is negative one, the slope is negative/decreasing. Correlation of 0 means no relation between the points (points are distributed roughly as a circle/sphere). As the correlation approaches -1 or 1, the circle of points flattens, with the spread increasing. Independent random variables will have a correlation of 0. However, uncorrelated random variables do not imply independence. Correlation does not imply causation! From a dataset we can compute correlation with the following formula: \\delta_{x,y} = \\frac{\\sum_{i=1}^n (x_i - \\bar{x})(y_i - \\bar{y})}{(n-1)s_x s_y} Transformations of RVs X is a CRV and Y = h(X) . Goal: Find the pdf of Y from the pdf of X . Assume h has an inverse. F_Y(y) = P(Y \\leq y) = P(h(X) \\leq y) = P(X \\leq h^{-1}(y) = F_X(h^{-1}(y) Therefore, f_Y(y) = f_X(h^{-1}(y)) \\frac{dh^{-1}}{dy}(y) If h has a decreasing inverse, f_Y(y) = -f_X(h^{-1}(y)) \\frac{dh^{-1}}{dy}(y) P(h(X) \\leq y) = P(X \\leq h^{-1}(y) only holds if h^{-1} is increasing. If h^{-1} is decreasing then P(h(X) \\leq y) = P(X \\geq h^{-1}(y) f_Y(h(x)) = f_X(x) \\lvert \\frac{1}{h'(x)} \\rvert Change of Variables Formula for 2 RVs X Y are CRV U, V = h(X, Y) f_{(u,v)}(h(x,y)) = f_{x,y}(x,y)\\lvert \\frac{1}{\\frac{\\partial u,v}{\\partial x,y}} \\rvert In the equation above, the denominator is the determinant of the jacobian. This represents the change in areas from X,Y to U,V (remember 3Blue1Brown determinant visualization intuition of differencec between areas).","title":"Joint Probability Distributions"},{"location":"math_science/prob_stats/joint-distributions/#joint-probability-distributions","text":"Many problems involves several random variables, thus it is useful to have models for the joint behavior of several random variables, especially the case where the variables are independent of each other.","title":"Joint Probability Distributions"},{"location":"math_science/prob_stats/joint-distributions/#joint-pmf-for-2-drvs","text":"A single pmf for a DRV X specifies the amount of mass for each possible value of X . The joint pmf of DRVs X and Y describes the amount of mass for each possible pair of values (x,y) . Let X and Y be two DRVs defined on sample space S of an experiment: p(x,y) = P(X = x \\cap Y = y) = \\sum_x sum_y p(x,y) The marginal pmfs of X and Y: p_X(x) = \\sum_y p(x,y) p_Y(y) = \\sum_x p(x,y) This makes sense since order to get the probability of a certain value of x, we take its probability as the sum over all possible y values. The marginal pmfs are useful for computing probabilites of events involving only one of the RVs.","title":"Joint PMF for 2 DRVs"},{"location":"math_science/prob_stats/joint-distributions/#joint-pdf-for-2-crvs","text":"A single pdf for a CRV X specifies the amount of mass per unit length for each possible value of X on an interval/set. A joint pdf of CRVs X and Y specifies the amount of mass per unit area for each possible pair of values (x,y) . Let X and Y be two CRVs and A a two-dimensional set. P[(X,Y) \\in A] = \\int_A \\int f(x,y)dx dy Then f(x,y) is the joint pdf with properties: 1) f(x,y) \\geq 0 2) \\int_{-\\infty}^\\infty \\int_{-\\infty}^\\infty f(x,y) dx dy = 1 If A is a two-dimensional rectangle: P(a \\leq X \\leq b, c \\leq Y \\leq d) = \\int_a^b \\int_c^d f(x,y)dy dx The marginal pdfs for X and Y : f_X(x) = \\int_{-\\infty}^{\\infty} f(x,y) dy f_Y(y) = \\int_{-\\infty}^{\\infty} f(x,y) dx","title":"Joint PDF for 2 CRVs"},{"location":"math_science/prob_stats/joint-distributions/#independence-of-2-rv","text":"DEF: Two RVs X and Y are independent if \\forall (x,y) p(x,y) = p_X(x)*p_Y(y) for DRVs f(x,y) = f_X(x)*f_Y(y) for CRVs","title":"Independence of 2 RV"},{"location":"math_science/prob_stats/joint-distributions/#independence-of-n-rv","text":"Def: x_1 ... x_n are independent RV if (for any subset a_1 to a_r ) for DRV P(x_{a_1}, ..., x_{a_r}) = P(x_{a_1}) * ... *P(x_{a_r}) for CRV f(x_{a_1}, ..., x_{a_r}) = f(x_{a_1}) * ... *f(x_{a_r})","title":"Independence of n RV"},{"location":"math_science/prob_stats/joint-distributions/#multinomial-distribution","text":"Model: n independent trials with replacement with r possible outcomes each. P_i = prob of getting ith outcome i = 1, ..., r . X_i = # times the ith outcome appears The jpmf of X_1 ,... X_r has a multinomial distribution. P(X_1, \\cdots , X_r) = \\frac{n!}{X_1!X_2! \\cdots X_r!}P_1^{X_1}P_2^{X_2} \\cdots P_r^{X_r} Divide by the number of permutations of each element to remove permutations from the total number of ways the elements can be arranged/","title":"Multinomial Distribution"},{"location":"math_science/prob_stats/joint-distributions/#expected-value-for-functions-of-2-rv","text":"X, Y are RV and Z = h(X,Y) . Remeber that the expected value can be thought of as a weighted average so the same idea extends to functions of 2 RV: DRV: E(Z) = \\sum_X \\sum_Y h(X,Y)P(X,Y) CRV: E(Z) = \\int_{-\\infin}^{\\infin}\\int_{-\\infin}^{\\infin} h(x,y) dy dx Note: You can change the order of summation/integration when the series is convergent (i dont really understand why) Propositions: 1) E(aX + Y) = aE(X) + E(Y) 2) If X,Y are independent, then E(X,Y) = E(X)E(Y) A counterexample s can be found such that the reverse of 2) does not hold meaning E(X,Y) = E(X)E(Y) does not imply independence of X and Y . Proof of 1) \\begin{aligned} E(aX+Y) &= \\sum_X \\sum_Y (aX+Y)P(X,Y) \\\\ &= a \\sum_X \\sum_Y X P(X,Y) + \\sum_X \\sum_Y YP(X,Y) \\\\ &= a \\sum_X X \\sum_Y P(X,Y) + \\sum_Y Y \\sum_X P(X,Y) \\\\ &= a \\sum_X X \\sum_Y P_X(X) + \\sum_Y Y \\sum_X P_Y(Y) \\\\ &= aE(X) + E(Y) \\end{aligned} ## Covariance DEF: X,Y are RV. Then Cov(X,Y) = E((x- \\mu_x)(Y-\\mu_y)) = E(X,Y) - E(X)E(Y)","title":"Expected Value for Functions of 2 RV"},{"location":"math_science/prob_stats/joint-distributions/#interpretations","text":"Covariance measures how much X and Y are spread since Cov(X,X) = \\sigma^2 How much are X and Y related How much X and Y fail to be independent Cov(X,Y) = 0 does not imply independence as demonstrated by the counterexample to proposition 2 above. How linear is the relation between X and Y","title":"Interpretations"},{"location":"math_science/prob_stats/joint-distributions/#examples","text":"The leftmost graph reprsents X and Y variables highly related in an inversely proportional way meaning when X increases, Y decreases and when X decresases, Y increases. The rightmost graph represents X and Y variables highly related in a directly proprtional way.","title":"Examples"},{"location":"math_science/prob_stats/joint-distributions/#properties","text":"Cov(aX,Z) = aCov(X,Z) This implies Cov(aX,aX) = a^2Cov(X,X) . Cov(aX + bY, Z) = aCov(X,Z) + bCov(Y,Z)","title":"Properties"},{"location":"math_science/prob_stats/joint-distributions/#correlation","text":"DEF: X and Y are random vars. Corr(X,Y) = \\delta_{x,y} = \\frac{Cov(X,Y)}{\\sigma_x \\sigma_y} Properties: 1) a,c > 0 or a, c <0 implies Corr(aX+b, cY+d) = Corr(X,Y) 2) -1 \\leq Corr(X,Y) \\leq 1 3) Corr(X,Y) = \\pm 1 iff Y = aX +b for some a \\neq 0 Correlation is unrelated to the value of the slope. Simply means when it is one, the slope is positive/increasing. WHen it is negative one, the slope is negative/decreasing. Correlation of 0 means no relation between the points (points are distributed roughly as a circle/sphere). As the correlation approaches -1 or 1, the circle of points flattens, with the spread increasing. Independent random variables will have a correlation of 0. However, uncorrelated random variables do not imply independence. Correlation does not imply causation! From a dataset we can compute correlation with the following formula: \\delta_{x,y} = \\frac{\\sum_{i=1}^n (x_i - \\bar{x})(y_i - \\bar{y})}{(n-1)s_x s_y}","title":"Correlation"},{"location":"math_science/prob_stats/joint-distributions/#transformations-of-rvs","text":"X is a CRV and Y = h(X) . Goal: Find the pdf of Y from the pdf of X . Assume h has an inverse. F_Y(y) = P(Y \\leq y) = P(h(X) \\leq y) = P(X \\leq h^{-1}(y) = F_X(h^{-1}(y) Therefore, f_Y(y) = f_X(h^{-1}(y)) \\frac{dh^{-1}}{dy}(y) If h has a decreasing inverse, f_Y(y) = -f_X(h^{-1}(y)) \\frac{dh^{-1}}{dy}(y) P(h(X) \\leq y) = P(X \\leq h^{-1}(y) only holds if h^{-1} is increasing. If h^{-1} is decreasing then P(h(X) \\leq y) = P(X \\geq h^{-1}(y) f_Y(h(x)) = f_X(x) \\lvert \\frac{1}{h'(x)} \\rvert","title":"Transformations of RVs"},{"location":"math_science/prob_stats/joint-distributions/#change-of-variables-formula-for-2-rvs","text":"X Y are CRV U, V = h(X, Y) f_{(u,v)}(h(x,y)) = f_{x,y}(x,y)\\lvert \\frac{1}{\\frac{\\partial u,v}{\\partial x,y}} \\rvert In the equation above, the denominator is the determinant of the jacobian. This represents the change in areas from X,Y to U,V (remember 3Blue1Brown determinant visualization intuition of differencec between areas).","title":"Change of Variables Formula for 2 RVs"},{"location":"math_science/prob_stats/rv/","text":"Discrete Random Variables Binomial Distribution Negative Binomial Distribution Hypergeometric Distribution Geometric Distribution Poisson Distribution Continuous Random Variables Uniform Distribution Uses Normal Distribution Uses Exponential Distribution Uses Gamma Distribution Uses","title":"Random Variables"},{"location":"math_science/prob_stats/rv/#discrete-random-variables","text":"","title":"Discrete Random Variables"},{"location":"math_science/prob_stats/rv/#binomial-distribution","text":"","title":"Binomial Distribution"},{"location":"math_science/prob_stats/rv/#negative-binomial-distribution","text":"","title":"Negative Binomial Distribution"},{"location":"math_science/prob_stats/rv/#hypergeometric-distribution","text":"","title":"Hypergeometric Distribution"},{"location":"math_science/prob_stats/rv/#geometric-distribution","text":"","title":"Geometric Distribution"},{"location":"math_science/prob_stats/rv/#poisson-distribution","text":"","title":"Poisson Distribution"},{"location":"math_science/prob_stats/rv/#continuous-random-variables","text":"","title":"Continuous Random Variables"},{"location":"math_science/prob_stats/rv/#uniform-distribution","text":"","title":"Uniform Distribution"},{"location":"math_science/prob_stats/rv/#uses","text":"","title":"Uses"},{"location":"math_science/prob_stats/rv/#normal-distribution","text":"","title":"Normal Distribution"},{"location":"math_science/prob_stats/rv/#uses_1","text":"","title":"Uses"},{"location":"math_science/prob_stats/rv/#exponential-distribution","text":"","title":"Exponential Distribution"},{"location":"math_science/prob_stats/rv/#uses_2","text":"","title":"Uses"},{"location":"math_science/prob_stats/rv/#gamma-distribution","text":"","title":"Gamma Distribution"},{"location":"math_science/prob_stats/rv/#uses_3","text":"","title":"Uses"},{"location":"software_design/big3/","text":"Classes Separate the public interface from the specifics of the implementation Everything is private by default (public in a struct) public interface provides the abstraction Encapsulation separates the implementation details from the public interface Data Hiding- one of type of encapsulation where we use private data members/functions Base Member Initialization List Every variable will be constructed before getting into the body of the constructor as a result of the compiler. Therefore we want to use the BMI to prevent doubling the work. Initialize all variables in the BMI (lots of things are able to be initialized including arrays). Order of initialization in BMI should be the same as order declared in the header (compiler doesn't care but good for consistency). Note the upper most base class is always initialized first. Initialization is the process of turning raw storage into an object. Assignment is the process of replacing the existing state of a well-defined object with a new state (never performed on raw storage). Big 3 Destructor Copy Constructor Copy Assignment Operator When one of the big 3 needs custom behavior, all of them probably will. Best practice to explicitly define the behavior of the big 3 even if it uses default functionality (serves as documentation). Resource Destructor Purpose: destroy items that are allocated onto the heap Default destructor does not cause memory leaks for primitve data types. Default destructor causes memory leaks when using pointers in complex data types because the data at the allocated memory address is not freed up (memory leak) Should not be called explicitly Called by compiler when object goes out of scope or when delete is called on an object Called in reverse order of the constructors for a heierachy of base classes Copy Constructor Purpose: Creates a new object instance with same values as existing object Different from the assignment operator in that it creates a new object instead of just setting existing objects to be equal to another Copying involves allocating memory for the data members and then initializing the data members to be the same as those of the referenced object. Called in 3 instances: 1. Traditional use c++ SomeClass a; SomeClass b(a); 2. Assignment operator is not called because b hasn't been initialized c++ SomeClass a; SomeClass b = a; 3. Passing or returning an object by value creates a copy of that object Default copy constructor does member wise copy which results in a shallow copies when dealing with pointers. Therefore, we define our own copy ctor for most classes we write Example Copy Constructor: An object of the same type is passed by constant (don't want to change existing object) reference (can't be passed by value since that would require copy constructor). SomeClass(const SomeClass &rhs ) { // Any pointer manipulation to prevent shallow copies } Copy Assignment Operator Purpose: set an existing object to be the same as another existing object of the same type Often overloaded to eliminate the problems caused by memberwise assignment when using pointers. Assignment involves: 1. Check for self assignment (assignining an object to itself) 2. Deleting the original items stored in the object's data members 3. Allocating memory for new items 4. Copying the other object's data members to the current object - Best practice to use copy constructor to keep code DRY 5. Return the object (allows for chaining assignment operators) Specifying Default and Delete Behavior Set copy ctor or assignment operatort to equal delete in the header to make it clear the user should not use them Will generate a compiler error if used Prevents the compiler from generating default implementations Certain cases (e.g. cout and files) its not acceptable to make copies or assignments Stack(const Stack &rhs) = delete; Stack &operator=(const Stack &rhs) = delete; Set copy ctor or assignment operatort to equal default in the header to make it clear the compiler will generate default implementations Serves as good documentation for user of the class Stack(const Stack &rhs) = default; Stack &operator=(const Stack &rhs) = default; Garbage Collection A program's executable includes automatic behavior that at various intervals finds all unreachable allocated memory locations (e.g., by comparing all reachable memory with all previously-allocated memory), and automatically frees such unreachable memory Can reduce the impact of memory leaks at the expense of runtime overhead Not implemented in standard C++ but is used in higher-level languages like Python and Java All C++ does is call destructor when variables/objects go out of the scope they were initialized in Therefore, C++ doesn't call the destructor on reference variables passed into functions when that function's scope ends Destructors for primitive data types works fine but destructors for more complex objects must be defined by user","title":"The Big 3"},{"location":"software_design/big3/#classes","text":"Separate the public interface from the specifics of the implementation Everything is private by default (public in a struct) public interface provides the abstraction Encapsulation separates the implementation details from the public interface Data Hiding- one of type of encapsulation where we use private data members/functions","title":"Classes"},{"location":"software_design/big3/#base-member-initialization-list","text":"Every variable will be constructed before getting into the body of the constructor as a result of the compiler. Therefore we want to use the BMI to prevent doubling the work. Initialize all variables in the BMI (lots of things are able to be initialized including arrays). Order of initialization in BMI should be the same as order declared in the header (compiler doesn't care but good for consistency). Note the upper most base class is always initialized first. Initialization is the process of turning raw storage into an object. Assignment is the process of replacing the existing state of a well-defined object with a new state (never performed on raw storage).","title":"Base Member Initialization List"},{"location":"software_design/big3/#big-3","text":"Destructor Copy Constructor Copy Assignment Operator When one of the big 3 needs custom behavior, all of them probably will. Best practice to explicitly define the behavior of the big 3 even if it uses default functionality (serves as documentation). Resource","title":"Big 3"},{"location":"software_design/big3/#destructor","text":"Purpose: destroy items that are allocated onto the heap Default destructor does not cause memory leaks for primitve data types. Default destructor causes memory leaks when using pointers in complex data types because the data at the allocated memory address is not freed up (memory leak) Should not be called explicitly Called by compiler when object goes out of scope or when delete is called on an object Called in reverse order of the constructors for a heierachy of base classes","title":"Destructor"},{"location":"software_design/big3/#copy-constructor","text":"Purpose: Creates a new object instance with same values as existing object Different from the assignment operator in that it creates a new object instead of just setting existing objects to be equal to another Copying involves allocating memory for the data members and then initializing the data members to be the same as those of the referenced object. Called in 3 instances: 1. Traditional use c++ SomeClass a; SomeClass b(a); 2. Assignment operator is not called because b hasn't been initialized c++ SomeClass a; SomeClass b = a; 3. Passing or returning an object by value creates a copy of that object Default copy constructor does member wise copy which results in a shallow copies when dealing with pointers. Therefore, we define our own copy ctor for most classes we write Example Copy Constructor: An object of the same type is passed by constant (don't want to change existing object) reference (can't be passed by value since that would require copy constructor). SomeClass(const SomeClass &rhs ) { // Any pointer manipulation to prevent shallow copies }","title":"Copy Constructor"},{"location":"software_design/big3/#copy-assignment-operator","text":"Purpose: set an existing object to be the same as another existing object of the same type Often overloaded to eliminate the problems caused by memberwise assignment when using pointers. Assignment involves: 1. Check for self assignment (assignining an object to itself) 2. Deleting the original items stored in the object's data members 3. Allocating memory for new items 4. Copying the other object's data members to the current object - Best practice to use copy constructor to keep code DRY 5. Return the object (allows for chaining assignment operators)","title":"Copy Assignment Operator"},{"location":"software_design/big3/#specifying-default-and-delete-behavior","text":"Set copy ctor or assignment operatort to equal delete in the header to make it clear the user should not use them Will generate a compiler error if used Prevents the compiler from generating default implementations Certain cases (e.g. cout and files) its not acceptable to make copies or assignments Stack(const Stack &rhs) = delete; Stack &operator=(const Stack &rhs) = delete; Set copy ctor or assignment operatort to equal default in the header to make it clear the compiler will generate default implementations Serves as good documentation for user of the class Stack(const Stack &rhs) = default; Stack &operator=(const Stack &rhs) = default;","title":"Specifying Default and Delete Behavior"},{"location":"software_design/big3/#garbage-collection","text":"A program's executable includes automatic behavior that at various intervals finds all unreachable allocated memory locations (e.g., by comparing all reachable memory with all previously-allocated memory), and automatically frees such unreachable memory Can reduce the impact of memory leaks at the expense of runtime overhead Not implemented in standard C++ but is used in higher-level languages like Python and Java All C++ does is call destructor when variables/objects go out of the scope they were initialized in Therefore, C++ doesn't call the destructor on reference variables passed into functions when that function's scope ends Destructors for primitive data types works fine but destructors for more complex objects must be defined by user","title":"Garbage Collection"},{"location":"software_design/exceptions/","text":"Exception Handling Purpose: permit the program to catch and handle errors rather than let it occur and suffer the consequences Used when system can recover from the error causing the exception Exception Handler- recovery procedure If no catch function, the terminate function is called (terminate calls abort function that aborts the program) Properly written exception safe code employs relatively few try blocks try { throw std::overflow_error(\"overflow error in push\") } catch (std::overflow_error &excep) { // exception handler is here std::cout << excep.what() << std::endl; } catch (...) { std::cout << \"Unknown exception\" << std::endl; } Throw Can throw anything but error types in standard library are typically used If a function throws a const object, the catch handler argument type must be declared const Throw lists for functions are bad practice but you will see them in legacy code Unwinding the stack refers to when an expection is thrown void func(int x) { char* fizz = new char[1024]; std::string s(\"Test\"); if(x) throw std::runtime_error(\"explosion\"); delete[] test; } In the above example, memory allocated for fizz will be leaked if an exception is thrown b/c delete[] fizz is never reached. However, memory allocated for s will be properly destructed b/c throwing an exception unwinds the stack meaning the destructor will be called on objects in each of the stack frames until a try catch block is reached. Since std::string has a properly defined destructor, s will not create a memory leak when an exception is thrown. Constructors & Destructors Exceptions thrown in constructors will cause the destructors to be called for any objects built as part of the object being constructed before the exception is thrown Don't throw exceptions in a destructor","title":"Exception Handling"},{"location":"software_design/exceptions/#exception-handling","text":"Purpose: permit the program to catch and handle errors rather than let it occur and suffer the consequences Used when system can recover from the error causing the exception Exception Handler- recovery procedure If no catch function, the terminate function is called (terminate calls abort function that aborts the program) Properly written exception safe code employs relatively few try blocks try { throw std::overflow_error(\"overflow error in push\") } catch (std::overflow_error &excep) { // exception handler is here std::cout << excep.what() << std::endl; } catch (...) { std::cout << \"Unknown exception\" << std::endl; }","title":"Exception Handling"},{"location":"software_design/exceptions/#throw","text":"Can throw anything but error types in standard library are typically used If a function throws a const object, the catch handler argument type must be declared const Throw lists for functions are bad practice but you will see them in legacy code Unwinding the stack refers to when an expection is thrown void func(int x) { char* fizz = new char[1024]; std::string s(\"Test\"); if(x) throw std::runtime_error(\"explosion\"); delete[] test; } In the above example, memory allocated for fizz will be leaked if an exception is thrown b/c delete[] fizz is never reached. However, memory allocated for s will be properly destructed b/c throwing an exception unwinds the stack meaning the destructor will be called on objects in each of the stack frames until a try catch block is reached. Since std::string has a properly defined destructor, s will not create a memory leak when an exception is thrown.","title":"Throw"},{"location":"software_design/exceptions/#constructors-destructors","text":"Exceptions thrown in constructors will cause the destructors to be called for any objects built as part of the object being constructed before the exception is thrown Don't throw exceptions in a destructor","title":"Constructors &amp; Destructors"},{"location":"software_design/inheritance/","text":"Inheritance Single Inheritance: occurs when a derived class inherits from only one parent class Multiple Inheritance: allows a class to inherit from multiple classes Error prone and should be avoided Big 3 are not inherited from a base class by a derived class Assignment operator is not inherited from the base class Will be provided with compiler generated one if used and not implemented by the user B publicly inheriting A creates the relationship: B is an instance of A private and protected inheritance do not create the same \"is a\" relationship Derived Classes Have access to base class' public and protected behaviors Protected- used for inheritance. Allows derived class access to something not public class A{ } class B: protected A { // everything public in A becomes protected in B } class C: private A { // everything public/private in A becomes private in B } Defines new attributes and behaviors may override the behaviors of the base class intended to be more specific than the base class constructor for the base class must be called from the derived class constructor in order to initialzie the base class members in the derived class Non explicitly calling it will result in the default constructor being called implicitly DerviedClass::DerivedClass(parameters) : BaseClass(parameters) {} virtual double func1() const { return 0.0; } default returns 0.0 virtual void func() const = 0; forces the derived class to implement the function Example implementation: void func() const override { //do something } Constructor & Destructor When derived class constructor is called 1) Base Class constructor is called to create an instance of the base class (done implicitly or explicitly) 2) Constructor for the derived class is executed Think of an onion (build up dervied object, layer by layer) When derived class destructor is called 1) Derived class destructor is executed 2) Base class destructor function is executed Reverse order of ctor, destroy the onion layer by layer Overriding Dervied version must have same function signature as base version Dervied version may include a call to the base version Provides more functionality specific to the derived class Abstract Class A base class that will never have an object instantiated from it Provides a generic interface Defined as any class that contains at least one pure virtual function (declare but provide no implementation of) Pure virtual function: virtual void func() const = 0; The equals zero makes the func pure virtual instead of just virtual Virtual Function A function that is expected to be overriden by a derived class Incudes full method signature, return type, and may provide default implementation Declared in public portion of the class Must not be static or a friend of another class Pure virtual functions must be overridden If derived class doesn't implement a pure virtual function, the derived class is also an abstract base class Non-pure virtual functions can be overidden but do not have to be A function defined as virtual in the base class makes it virutal for all classes derived from the base class Class with virtual functions should contain a virtual destructor Ensures the correct sequence of destructors is called Base class dtor must be virtual Should be accessed using pointer or reference of base class type to achieve run time polymorphism Why use Virtual Functions? Basic inheritance and overriding gives us the expected behavior with concrete instances Virtual functions allow us to work with a pointer to the base class Virtual functions defined in the base classes permit dynamic binding allowing runtime polymorphism Dynamic Binding A virtual function invoked using a reference to an objcet Allows program to choose appropraite method designed to identify the method for a particular object type at runtime Static binding requires object type to be defined at compile time Achieved using vtables Polymorphism Occurs whens multiple objects from different classes are related by inheritance from the same base class Most useful when there are a series of related objects that need to be treated in a uniform manner Polymorphic means having many forms Can have multiple behaviors for the same function depending on the context Achieved by using virtual functions and overriding these methods in derived classes Virtual Function Table Created at compile time and put in static memory Used at runtime to achieve dynamic binding and runtime polymorphism Compiler generates a vtable for each class with at least one method marked as virtual Only virtual methods are included in the vtable Example vtable for the shape example code from lecture 9: Shape Class ~Shape local or {} local implementation area() const {} local implementation volume() const {} local implementation pShapeName() const =0 pure virtual print() const = 0 pure virtual Shape class is abstract since there are pure virtual methods in the vtable Point Class ~Point local {} local implementation area() const Shape::area implementation in shape class volume() const Shape::volume implementation in shape class pShapeName() const {} own implementation print() const {} own implementation Point class is concrete since there are no pure virtual methods in the vtable Circle Class ~Circle local {} local implementation area() const {} local implementation volume() const Shape::volume implementation in shape class pShapeName() const {} local implementation print() const {} local implementation Point class is concrete since there are no pure virtual methods in the vtable When an object of a class containing virtual functions is instantiated, the compiler attaches a pointer to the class's vtable at the front of the object Memory and processing costs associated with virtual functions Increased size of object to hold vtable's address Increased compile time to create the vtable for each class with virtual functions More efficient to compute lookup table at compile time rather than determining these relationships at runtime For each function call, there is an extra step of looking up the address in the table to the correct implementation If marked virtual but not pure virtual, the class will provide its own implementation for it Derived class inherits all of the virtual functions from base class Polymorphism and use of vtable will be used when the method is marked as virtual and the method is called via a pointer or reference. This means functions in base class with same name will not be hidden like they are when doing override and using concrete instances Design Considerations Only use inheritance where additional layers of abstraction makes sense Class hierarchies promote code reuse Stand alone class --> bsase classes can make refactoring difficult Can create issues with slicing as a result of concrete base classes being able to be instantiated Should make base classes abstract Clarifications Overloading is creating a method with the same name as an existing method but with different parameters Overriding is creating a method in a derived class with the same name and parameters (same signature) as an existing method in its base class Polymorphism- ability of different object to be accessed by a common interface Polymorphism and overloading are related but not the same Standard hiding of methods of the same name in the base class will occur when the derived class has a concrete instance created Dynamic binding and runtime polymorphism occurs when using pointers/references of the base class to point to instances of the derived classes (gives standard interface to access different, but related objects --> definition of polymorphism)","title":"Inheritance"},{"location":"software_design/inheritance/#inheritance","text":"Single Inheritance: occurs when a derived class inherits from only one parent class Multiple Inheritance: allows a class to inherit from multiple classes Error prone and should be avoided Big 3 are not inherited from a base class by a derived class Assignment operator is not inherited from the base class Will be provided with compiler generated one if used and not implemented by the user B publicly inheriting A creates the relationship: B is an instance of A private and protected inheritance do not create the same \"is a\" relationship","title":"Inheritance"},{"location":"software_design/inheritance/#derived-classes","text":"Have access to base class' public and protected behaviors Protected- used for inheritance. Allows derived class access to something not public class A{ } class B: protected A { // everything public in A becomes protected in B } class C: private A { // everything public/private in A becomes private in B } Defines new attributes and behaviors may override the behaviors of the base class intended to be more specific than the base class constructor for the base class must be called from the derived class constructor in order to initialzie the base class members in the derived class Non explicitly calling it will result in the default constructor being called implicitly DerviedClass::DerivedClass(parameters) : BaseClass(parameters) {} virtual double func1() const { return 0.0; } default returns 0.0 virtual void func() const = 0; forces the derived class to implement the function Example implementation: void func() const override { //do something }","title":"Derived Classes"},{"location":"software_design/inheritance/#constructor-destructor","text":"When derived class constructor is called 1) Base Class constructor is called to create an instance of the base class (done implicitly or explicitly) 2) Constructor for the derived class is executed Think of an onion (build up dervied object, layer by layer) When derived class destructor is called 1) Derived class destructor is executed 2) Base class destructor function is executed Reverse order of ctor, destroy the onion layer by layer","title":"Constructor &amp; Destructor"},{"location":"software_design/inheritance/#overriding","text":"Dervied version must have same function signature as base version Dervied version may include a call to the base version Provides more functionality specific to the derived class","title":"Overriding"},{"location":"software_design/inheritance/#abstract-class","text":"A base class that will never have an object instantiated from it Provides a generic interface Defined as any class that contains at least one pure virtual function (declare but provide no implementation of) Pure virtual function: virtual void func() const = 0; The equals zero makes the func pure virtual instead of just virtual","title":"Abstract Class"},{"location":"software_design/inheritance/#virtual-function","text":"A function that is expected to be overriden by a derived class Incudes full method signature, return type, and may provide default implementation Declared in public portion of the class Must not be static or a friend of another class Pure virtual functions must be overridden If derived class doesn't implement a pure virtual function, the derived class is also an abstract base class Non-pure virtual functions can be overidden but do not have to be A function defined as virtual in the base class makes it virutal for all classes derived from the base class Class with virtual functions should contain a virtual destructor Ensures the correct sequence of destructors is called Base class dtor must be virtual Should be accessed using pointer or reference of base class type to achieve run time polymorphism","title":"Virtual Function"},{"location":"software_design/inheritance/#why-use-virtual-functions","text":"Basic inheritance and overriding gives us the expected behavior with concrete instances Virtual functions allow us to work with a pointer to the base class Virtual functions defined in the base classes permit dynamic binding allowing runtime polymorphism","title":"Why use Virtual Functions?"},{"location":"software_design/inheritance/#dynamic-binding","text":"A virtual function invoked using a reference to an objcet Allows program to choose appropraite method designed to identify the method for a particular object type at runtime Static binding requires object type to be defined at compile time Achieved using vtables","title":"Dynamic Binding"},{"location":"software_design/inheritance/#polymorphism","text":"Occurs whens multiple objects from different classes are related by inheritance from the same base class Most useful when there are a series of related objects that need to be treated in a uniform manner Polymorphic means having many forms Can have multiple behaviors for the same function depending on the context Achieved by using virtual functions and overriding these methods in derived classes","title":"Polymorphism"},{"location":"software_design/inheritance/#virtual-function-table","text":"Created at compile time and put in static memory Used at runtime to achieve dynamic binding and runtime polymorphism Compiler generates a vtable for each class with at least one method marked as virtual Only virtual methods are included in the vtable Example vtable for the shape example code from lecture 9: Shape Class ~Shape local or {} local implementation area() const {} local implementation volume() const {} local implementation pShapeName() const =0 pure virtual print() const = 0 pure virtual Shape class is abstract since there are pure virtual methods in the vtable Point Class ~Point local {} local implementation area() const Shape::area implementation in shape class volume() const Shape::volume implementation in shape class pShapeName() const {} own implementation print() const {} own implementation Point class is concrete since there are no pure virtual methods in the vtable Circle Class ~Circle local {} local implementation area() const {} local implementation volume() const Shape::volume implementation in shape class pShapeName() const {} local implementation print() const {} local implementation Point class is concrete since there are no pure virtual methods in the vtable When an object of a class containing virtual functions is instantiated, the compiler attaches a pointer to the class's vtable at the front of the object Memory and processing costs associated with virtual functions Increased size of object to hold vtable's address Increased compile time to create the vtable for each class with virtual functions More efficient to compute lookup table at compile time rather than determining these relationships at runtime For each function call, there is an extra step of looking up the address in the table to the correct implementation If marked virtual but not pure virtual, the class will provide its own implementation for it Derived class inherits all of the virtual functions from base class Polymorphism and use of vtable will be used when the method is marked as virtual and the method is called via a pointer or reference. This means functions in base class with same name will not be hidden like they are when doing override and using concrete instances","title":"Virtual Function Table"},{"location":"software_design/inheritance/#design-considerations","text":"Only use inheritance where additional layers of abstraction makes sense Class hierarchies promote code reuse Stand alone class --> bsase classes can make refactoring difficult Can create issues with slicing as a result of concrete base classes being able to be instantiated Should make base classes abstract","title":"Design Considerations"},{"location":"software_design/inheritance/#clarifications","text":"Overloading is creating a method with the same name as an existing method but with different parameters Overriding is creating a method in a derived class with the same name and parameters (same signature) as an existing method in its base class Polymorphism- ability of different object to be accessed by a common interface Polymorphism and overloading are related but not the same Standard hiding of methods of the same name in the base class will occur when the derived class has a concrete instance created Dynamic binding and runtime polymorphism occurs when using pointers/references of the base class to point to instances of the derived classes (gives standard interface to access different, but related objects --> definition of polymorphism)","title":"Clarifications"},{"location":"software_design/iterators/","text":"Iterators Allow a program to access aggregated data in a container Allow us to write programs that do not depend on the type of container (e.g. array, vector, tree, etc.) The details of accessing the aggregated data iis hidden via the iterator interface Our code then interacts with the iterator, not the container directly Every container has its own class for its iterator Iterator Design Pattern Intent Access elements of a container (aggregate) without exposing its representation Applicability Require multiple traversal algorthims over a container Require a uniform traversal interface over different containers When container classes and traversal algorithms must vary independently Structure Aggregate is an abstract base class used for creating containers. ConcreteAggregate is a derived class that is a specific type of container (e.g. tree, hash map, list, etc.) Iterator is an abstract base class used for creating iterators on containers ConcreteIterator is a derived class that is a specific iterator implementation corresponding to the strucutre of a concrete container The use of Aggregate and Iterator abstract base classes lets client code be written against any generic container with an iterator Looping directly over linear containers like arrays make assumption on the subscript operators definition meaning it interacts directly with the container Using iterators makes algorithms more general and independent of the container since the iterators handle differencs between data structures such as linear vs tree STL Iterators C++ implementation of the iterator pattern Generalization of pointers since they are objects that point to other objects Central to generic programming b/c they are an interface btw containers and algorithms STL algorithms typically take iterators as arugments A container only needs to provide a way to access its elements using iterators Useful to add iterators to your own classes so they can be used with STL algorithms Not all containers support random-access (e.g. specifying the ith item to access) Containers that support random-access iterators can be used with all STL algos Input Iterators Used to read from a container Dereferenced to refer to some object Incremented to obtain next iterator in a sequence Must allow following operations: Copy Ctor and assignment operator == and != for comparison with other iterators of the same type * and ++ for incrementing which object is being pointed to Can be const prefix and postfix Output Iterators Used to write to a container More restrictive interface: = , == , and != don't need to be defined Must support non-const operator* Iterator Types Iterator categories depend on type parameterization rather than inheritance Iterator categories are hierarchical with more refined categories adding constraints Forward - start to end of container (supports ++ ) Bidirectional - iterate through elements forward and backward (supports ++ , -- ) list, set, multiset, map, & multimap Random Access - go forward n elements, get nth element (supports [] ) vector and deque Using Iterators begin() is the first element end() is whatever it means to be just after the last element begin()/end() are used to traverse front to back rbegin()/rend() are used to traverse back to front Range based for loops use iterators to easily go through containers: vector<int> = {1,2,3,4}; for(int i : v) { std::cout << i << std::endl; }","title":"Iterators"},{"location":"software_design/iterators/#iterators","text":"Allow a program to access aggregated data in a container Allow us to write programs that do not depend on the type of container (e.g. array, vector, tree, etc.) The details of accessing the aggregated data iis hidden via the iterator interface Our code then interacts with the iterator, not the container directly Every container has its own class for its iterator","title":"Iterators"},{"location":"software_design/iterators/#iterator-design-pattern","text":"","title":"Iterator Design Pattern"},{"location":"software_design/iterators/#intent","text":"Access elements of a container (aggregate) without exposing its representation","title":"Intent"},{"location":"software_design/iterators/#applicability","text":"Require multiple traversal algorthims over a container Require a uniform traversal interface over different containers When container classes and traversal algorithms must vary independently","title":"Applicability"},{"location":"software_design/iterators/#structure","text":"Aggregate is an abstract base class used for creating containers. ConcreteAggregate is a derived class that is a specific type of container (e.g. tree, hash map, list, etc.) Iterator is an abstract base class used for creating iterators on containers ConcreteIterator is a derived class that is a specific iterator implementation corresponding to the strucutre of a concrete container The use of Aggregate and Iterator abstract base classes lets client code be written against any generic container with an iterator Looping directly over linear containers like arrays make assumption on the subscript operators definition meaning it interacts directly with the container Using iterators makes algorithms more general and independent of the container since the iterators handle differencs between data structures such as linear vs tree","title":"Structure"},{"location":"software_design/iterators/#stl-iterators","text":"C++ implementation of the iterator pattern Generalization of pointers since they are objects that point to other objects Central to generic programming b/c they are an interface btw containers and algorithms STL algorithms typically take iterators as arugments A container only needs to provide a way to access its elements using iterators Useful to add iterators to your own classes so they can be used with STL algorithms Not all containers support random-access (e.g. specifying the ith item to access) Containers that support random-access iterators can be used with all STL algos","title":"STL Iterators"},{"location":"software_design/iterators/#input-iterators","text":"Used to read from a container Dereferenced to refer to some object Incremented to obtain next iterator in a sequence Must allow following operations: Copy Ctor and assignment operator == and != for comparison with other iterators of the same type * and ++ for incrementing which object is being pointed to Can be const prefix and postfix","title":"Input Iterators"},{"location":"software_design/iterators/#output-iterators","text":"Used to write to a container More restrictive interface: = , == , and != don't need to be defined Must support non-const operator*","title":"Output Iterators"},{"location":"software_design/iterators/#iterator-types","text":"Iterator categories depend on type parameterization rather than inheritance Iterator categories are hierarchical with more refined categories adding constraints Forward - start to end of container (supports ++ ) Bidirectional - iterate through elements forward and backward (supports ++ , -- ) list, set, multiset, map, & multimap Random Access - go forward n elements, get nth element (supports [] ) vector and deque","title":"Iterator Types"},{"location":"software_design/iterators/#using-iterators","text":"begin() is the first element end() is whatever it means to be just after the last element begin()/end() are used to traverse front to back rbegin()/rend() are used to traverse back to front Range based for loops use iterators to easily go through containers: vector<int> = {1,2,3,4}; for(int i : v) { std::cout << i << std::endl; }","title":"Using Iterators"},{"location":"software_design/misc/","text":"C++ Compiler 4 Steps: 1. Preprocessor: deletes comments, expands macros (anything with # prefix), replace file includes and constants with the values - #include brings in lots of files to create a larger temp file with everything needed - Summary: Pull together all needed code 2. Compiler: takes the code and produces architecture dependent assembly code (type, syntax, grammar rules are applied here) 3. Assembler: takes the assembly code and translates it to machine code - No commnon errors at this step 4. Linker: takes all seperate translation units and tries to link them together - Common Errors: symbol missing (declare and call a method but never define it), couldn't open output file (tried to build while debugger was running on the old executable) Clang and Gcc compiler will be used. Undefined behaviors are different between C++ compilers Command Line Arguments int main(int argc, char **argv) { } argc is the number of command line arguments (strings) **argv is a pointer to an array (a pointer) containing pointers to the command line strings Always one argument (the name of your program itself) When running a program the OS loader finds the executable on disk and passes in any additional arguments from the command line to the main function Explicit vs. Automatic Conversions A single argument constructor provides the ability to convert the value of the argument to the clas type. Implicit conversion converts the statement to a Class A { public: A(); A(int); A(const char*, int=0); } // implicit conversion: A c = 1; // same as A c = A(1) A c = \"someword\" // same as A c = A(\"someword\") Class A { public: A(); // don't need to give params names in the header but its helpful, only required in the cpp implementation explicit A(int); explicit A(const char*, int=0); } // implicit conversion no longer allowed A c = 1; // will now throw compiler errors A c = \"someword\" // same as A c = A(\"someword\") // allows: A a1; A a2 = A(1); A a3(1); A a4 = A(\"Test\"); A a6 = static_cast<A>(1); A* p = new A(1); Reference Another name for an existing object Not a pointer and doesn't behave like a pointer 3 Major differences from a pointer: 1) No null references 2) All references require initialization when they are declared 3) A reference always refers to the object with which it is initialized (cannot be made to refer to a different object later) References and Const reference to a non const cannot be initialized with a literal or temporary value a refernce to a const can be initialized with a literal or a temporary value double &cd = 12.3; // error! const double &cd = 12.3; //no error Function Calls: 1) Pass by value: calls copy constructor 2) Pass by pointer: Function call must send address of the variable: f(&<var-name>) Function def must use * to create an alias for the variable: <return-type> f(<data-type>* <var-name>) { ... } int test(char* letter) { return int(*letter) } char testLetter = 'a'; std::cout << test(&testLetter) << std::endl; // prints a 3) Pass by reference: allow Types not matching causes an attempt to implicitly cast to the correct type which effectively causes a copy call when making a temp copy Debugger Can set breakpoints to run the program until a certain line Can set watch points to run the program until a certain condition LLVM/GDB debuggers can be used from the terminal","title":"Misc"},{"location":"software_design/misc/#c-compiler","text":"4 Steps: 1. Preprocessor: deletes comments, expands macros (anything with # prefix), replace file includes and constants with the values - #include brings in lots of files to create a larger temp file with everything needed - Summary: Pull together all needed code 2. Compiler: takes the code and produces architecture dependent assembly code (type, syntax, grammar rules are applied here) 3. Assembler: takes the assembly code and translates it to machine code - No commnon errors at this step 4. Linker: takes all seperate translation units and tries to link them together - Common Errors: symbol missing (declare and call a method but never define it), couldn't open output file (tried to build while debugger was running on the old executable) Clang and Gcc compiler will be used. Undefined behaviors are different between C++ compilers","title":"C++ Compiler"},{"location":"software_design/misc/#command-line-arguments","text":"int main(int argc, char **argv) { } argc is the number of command line arguments (strings) **argv is a pointer to an array (a pointer) containing pointers to the command line strings Always one argument (the name of your program itself) When running a program the OS loader finds the executable on disk and passes in any additional arguments from the command line to the main function","title":"Command Line Arguments"},{"location":"software_design/misc/#explicit-vs-automatic-conversions","text":"A single argument constructor provides the ability to convert the value of the argument to the clas type. Implicit conversion converts the statement to a Class A { public: A(); A(int); A(const char*, int=0); } // implicit conversion: A c = 1; // same as A c = A(1) A c = \"someword\" // same as A c = A(\"someword\") Class A { public: A(); // don't need to give params names in the header but its helpful, only required in the cpp implementation explicit A(int); explicit A(const char*, int=0); } // implicit conversion no longer allowed A c = 1; // will now throw compiler errors A c = \"someword\" // same as A c = A(\"someword\") // allows: A a1; A a2 = A(1); A a3(1); A a4 = A(\"Test\"); A a6 = static_cast<A>(1); A* p = new A(1);","title":"Explicit vs. Automatic Conversions"},{"location":"software_design/misc/#reference","text":"Another name for an existing object Not a pointer and doesn't behave like a pointer 3 Major differences from a pointer: 1) No null references 2) All references require initialization when they are declared 3) A reference always refers to the object with which it is initialized (cannot be made to refer to a different object later)","title":"Reference"},{"location":"software_design/misc/#references-and-const","text":"reference to a non const cannot be initialized with a literal or temporary value a refernce to a const can be initialized with a literal or a temporary value double &cd = 12.3; // error! const double &cd = 12.3; //no error","title":"References and Const"},{"location":"software_design/misc/#function-calls","text":"1) Pass by value: calls copy constructor 2) Pass by pointer: Function call must send address of the variable: f(&<var-name>) Function def must use * to create an alias for the variable: <return-type> f(<data-type>* <var-name>) { ... } int test(char* letter) { return int(*letter) } char testLetter = 'a'; std::cout << test(&testLetter) << std::endl; // prints a 3) Pass by reference: allow Types not matching causes an attempt to implicitly cast to the correct type which effectively causes a copy call when making a temp copy","title":"Function Calls:"},{"location":"software_design/misc/#debugger","text":"Can set breakpoints to run the program until a certain line Can set watch points to run the program until a certain condition LLVM/GDB debuggers can be used from the terminal","title":"Debugger"},{"location":"software_design/operator-overloading/","text":"Operator Overloading Allows a programmer to define behaviors when built-in operators are applied to user defined types operator<symbol> is used for the function name of the operator to be overloaded class String { public: String &operator=(const String &); // assignment: returns by referenceto allow chaining/compounding assignments String operator+(const String &) const; // addition: const method b/c it does not alter the object, but returns a new one String operator-() const; // unary negator ... }; a = b // equivalent a.operator=(b) Compiler generates default implementation for assignment ( = ) and address ( & ) operator Cannot overload . , .* , :: , ?: , and sizeof operators Overloading an operator does not change: Operator precedence Associativity of the operator (important for unary operator) Arity of the operator (can't turn unary operator into a binary operator or vice versa) Meaning of how the operator works on objects of built-in types Overloading = and - operators does not overload -= operator An overloaded operator must have at least one operand that is a user defined type Cannot be used to create new operator symbols Overloaded oeprators must adhere to syntax of original operator Operator functions: 1) Member functions- usually use the this pointer implicity 2) Non-member functions- made friends so they have access to internal state of the user defined object Friendship Used for sharing private data members between classes class A{ public: int operator+(const B &rhs) { return this->foo + } private: int foo; } class B { public: friend class A; // any object A and all of its functions have access to private members in class B friend int A::operator+(const B &rhs); // grants only this method in class A access to private member variables in class B private: int bar; } Implementing an operator function as a non-member function of a class (e.g. overloading the insertion/extraction operator): // .h class A{ public: A(std::string a, std::string b, std::string c); friend std::ostream &operator<<(std::ostream &lhs, const A &rhs); // gives method access to the private member variables private: std::string a, b, c; } std::ostream &operator<<(std::ostream &lhs, const A &rhs); // .cpp A:A(std::string a, std::string b, std::string c): a(a), b(b), c(c) {} // returns a reference to the ostream that was passed in and modified by adding the data from the rhs object which is not modified in the process std::ostream &operator<<(std::ostream &lhs, const A &rhs) { lhs << rhs.a << \" \" << rhs.b << \" \" << rhs.c <<std::endl; return lhs; } Overloading Unary Operators Preference is to make the operator functions class members rather than non-member friend functions Prefix (increment and return the incremented value) and postfix (increment and return the value before it was incremented) Prefix is faster b/c it doesn't have to make a temp copy class A { public: A &operator++(); // prefix const A operator++(int) // postfix- called as A.operator(0); A &operator--(); // prefix const A operator--(int) // postfix } A &A::operator++() { ++*this; return this; } const A A::operator++(int) { A temp(*this); ++*this; return temp; } ++ and -- are often overloaded to support iterators and smart pointers When overloading ++ and -- , both prefix and postfix must be overloaded and each version will have a distinct signature due to the use of dummy parameters in the postfix operators Subscript Operator operator [] can be overloadded to return an object of a new class or return an element of the original array Usually a const and non-const version for reading and writing Can use const_cast to reduce code duplication and increase maintainability class TextBlock { public: ... const char& operator[](std::size_t position) const { // bounds checking // log access data // verify data integrity return text[position]; } char& operator[](std::size_t position) { return const_cast<char&>( const_cast<const TextBlock&>(*this)][position] ); // 1) adds const to *this // 2) calls const operator[] // 3) cast away const from returned value } ... } Overloading vs. Overriding Overloading - multiple functions w/ same name in same scope, but different signatures (e.g. different argument/return types, different parameters, etc.) When overloading functions, use the copy constructor to create new objects Overriding - derived class function has the same name and signature as a base class virtual function Overrriden mthods in a derived class will cause any methods of the same name (regardless of signature) in the base class to be hidden meaning they can't be used by the derived class Can override this default hiding behavior with a using class::method; line inside the derived class class A { public: bool process(Credit &); bool process(Acceptance &); } class B : public A{ public: using A::process; // no hiding of A's process methods bool process(Rejection &) }","title":"Operator Overloading"},{"location":"software_design/operator-overloading/#operator-overloading","text":"Allows a programmer to define behaviors when built-in operators are applied to user defined types operator<symbol> is used for the function name of the operator to be overloaded class String { public: String &operator=(const String &); // assignment: returns by referenceto allow chaining/compounding assignments String operator+(const String &) const; // addition: const method b/c it does not alter the object, but returns a new one String operator-() const; // unary negator ... }; a = b // equivalent a.operator=(b) Compiler generates default implementation for assignment ( = ) and address ( & ) operator Cannot overload . , .* , :: , ?: , and sizeof operators Overloading an operator does not change: Operator precedence Associativity of the operator (important for unary operator) Arity of the operator (can't turn unary operator into a binary operator or vice versa) Meaning of how the operator works on objects of built-in types Overloading = and - operators does not overload -= operator An overloaded operator must have at least one operand that is a user defined type Cannot be used to create new operator symbols Overloaded oeprators must adhere to syntax of original operator Operator functions: 1) Member functions- usually use the this pointer implicity 2) Non-member functions- made friends so they have access to internal state of the user defined object","title":"Operator Overloading"},{"location":"software_design/operator-overloading/#friendship","text":"Used for sharing private data members between classes class A{ public: int operator+(const B &rhs) { return this->foo + } private: int foo; } class B { public: friend class A; // any object A and all of its functions have access to private members in class B friend int A::operator+(const B &rhs); // grants only this method in class A access to private member variables in class B private: int bar; } Implementing an operator function as a non-member function of a class (e.g. overloading the insertion/extraction operator): // .h class A{ public: A(std::string a, std::string b, std::string c); friend std::ostream &operator<<(std::ostream &lhs, const A &rhs); // gives method access to the private member variables private: std::string a, b, c; } std::ostream &operator<<(std::ostream &lhs, const A &rhs); // .cpp A:A(std::string a, std::string b, std::string c): a(a), b(b), c(c) {} // returns a reference to the ostream that was passed in and modified by adding the data from the rhs object which is not modified in the process std::ostream &operator<<(std::ostream &lhs, const A &rhs) { lhs << rhs.a << \" \" << rhs.b << \" \" << rhs.c <<std::endl; return lhs; }","title":"Friendship"},{"location":"software_design/operator-overloading/#overloading-unary-operators","text":"Preference is to make the operator functions class members rather than non-member friend functions Prefix (increment and return the incremented value) and postfix (increment and return the value before it was incremented) Prefix is faster b/c it doesn't have to make a temp copy class A { public: A &operator++(); // prefix const A operator++(int) // postfix- called as A.operator(0); A &operator--(); // prefix const A operator--(int) // postfix } A &A::operator++() { ++*this; return this; } const A A::operator++(int) { A temp(*this); ++*this; return temp; } ++ and -- are often overloaded to support iterators and smart pointers When overloading ++ and -- , both prefix and postfix must be overloaded and each version will have a distinct signature due to the use of dummy parameters in the postfix operators","title":"Overloading Unary Operators"},{"location":"software_design/operator-overloading/#subscript-operator","text":"operator [] can be overloadded to return an object of a new class or return an element of the original array Usually a const and non-const version for reading and writing Can use const_cast to reduce code duplication and increase maintainability class TextBlock { public: ... const char& operator[](std::size_t position) const { // bounds checking // log access data // verify data integrity return text[position]; } char& operator[](std::size_t position) { return const_cast<char&>( const_cast<const TextBlock&>(*this)][position] ); // 1) adds const to *this // 2) calls const operator[] // 3) cast away const from returned value } ... }","title":"Subscript Operator"},{"location":"software_design/operator-overloading/#overloading-vs-overriding","text":"Overloading - multiple functions w/ same name in same scope, but different signatures (e.g. different argument/return types, different parameters, etc.) When overloading functions, use the copy constructor to create new objects Overriding - derived class function has the same name and signature as a base class virtual function Overrriden mthods in a derived class will cause any methods of the same name (regardless of signature) in the base class to be hidden meaning they can't be used by the derived class Can override this default hiding behavior with a using class::method; line inside the derived class class A { public: bool process(Credit &); bool process(Acceptance &); } class B : public A{ public: using A::process; // no hiding of A's process methods bool process(Rejection &) }","title":"Overloading vs. Overriding"},{"location":"software_design/pointers/","text":"Pointers A pointer is a variable that contains a memory address as its value Memory address points to the actual data Has a data type that indicates the type of data being stored at the memory address Declared using * operator like: int* a; Refrence/Address Operator: & obtains a variable's memory address Dereference Operator: * retrieves the data at the memory address a pointer stores When declared, pointers hold an unknown address until initialized To indicate pointing at nothing, use nullptr Why use them? Pointers are all 8-bytes (64-bits on 64-bit machines, 32-bits on 32-bit) so it is much more efficient to use memory addresses of large objects like images or videos than to actually move around the object and make copies of it when doing things like passing them to a function. Common Errors Syntax Using the dereference operator when initializing a pointer int* a; int b = 20; *a = &b; // error b/c using derefence operator a = &b // correct The 3rd line is an error b/c *a refers to data being stored at the unknown memory address a was initialized to. This will set the data at a to the memory address of b instead of making a point at b 's memory address. Note this will note cause a compiler error, just a tricky to find bug. However, this is valid and perform the desired functionality because * is not being used for dereferencing but rather declaring a pointer: int b = 20; int *a = &b; Forgetting the * before each pointer when declaring multiple on the same line int* ptr1, ptr2; // ptr1 will be an int pointer but ptr2 will just be an int int *ptr1, *ptr2; // makes both of them int pointers Good practice to declare one pointer per line to avoid this. Runtime Using a derefence operator * when the pointer has not been intialized. This causes undefined behavior meaning the program could crash if the pointer holds an address the program is not allowed to access. Dereferencing a null pointer. This causes the program to crash. Memory overflow can be dangerous b/c it results in overwriting data anywhere in memory (can be OS, other programs, etc.) Aliasing- changing the memory address a pointer points to Dereferencing Derefencing a pointer means accessing the value stored at the memory address the pointer contains char* p = \"abc\" // stores 'a', 'b', 'c' in 3 continuous chunks of memory and p points to the location of a // Pointer arithmetic can be used to access b and c assert(*p == 'a'); // The first character at address p will be 'a' assert(p[1] == 'b'); // p[1] actually dereferences the pointer: p + 1 * (size of p in memory) assert(*(p + 1) == 'b'); // Another notation for p[1] Change data at the address pointed to by derferencing the pointer: *p = 'z' // now the string of chars is zbc assert(*p = 'z') Move pointers through the data: ++p; // Increment p so now it points to 'b' assert(*p == 'b'); Member Access Operator struct SomeStruct {int a;}; SomeStruct s; SomeStruct* structPtr = s; structPtr->a = 1; // is cleaner than: (*structPtr).a = 1; Arrays Represented internally as a pointer to the first element Accessing elements using indexing is actually just using pointer arithmetic A variable declared as an array is the same as a variable declared as a pointer When passing an array to a function, only the address of the array is copied into the parameter so any changes to the array in the function will cause a change to the original array b/c its shared void f1(int array[]) = void f1(int *array) [] and * are effectively the same but [] provides better documentation/readability Array of pointers (multi-dimensional arrays): ** or *[] can be used to declare arrays of pointers Allows a program to contain elements that vary in size (saves memory which is important for programs using large data objects) Strings represented internally as a character array ending with the null character \\0 since it is a character array, pointer arithmetic and everything can be done on strings Const const ensures data cannot be modified and the compiler will enforce this constraint Use as much as possible const int num; num = 10; // error! const char let = 'a'; // good! let = 'b'; // error New and Delete Operators new allocates memory for the given type and returns a pointer to the allocated memory If the type is a class, it calls the constructor after allocating memory for the class's data members Can pass arguments to the constructor by passing them in parentheses after the class name (ex: ClassA a = new ClassA(\"Test\") ) To allocate a continuous chunk of memory for an array of objects use new SomeClass[size] Default constructor called for each object in array (class must have a constructor that can take 0 arguments otherwise a compiler error will occur) delete deallocates/frees a block of memory allocated with new No effect if used on nullptr Dereferencing after using delete will cause undefined behavior if pointer is not set to nullptr Calling delete on pointer not allocated with new has undefined behavior and is a logic error Must be called on a pointer to memory allocated using new Doesn't set a pointer to nullptr just frees the memory (must be done manually) To delete an array of objects use delete[] array Calling destructor instead of delete fails to actually free up the memory Memory Regions Memory has 3 different regions: data, stack, and heap. There are 3 types of memory allocation: static, dynamic, and automatic A program's memory usage includes 3 different regions: Static - global & static local variables are allocated at compilation time (fixed size) Reserved at compile time in the program's data segment Allocated as a fixed block of memory Stores any global and static local variables Stores the actual code Allocated when program starts and deallocated when program exists Automatic - each function call allocates a new block of memory called a stack frame to holds its local variables. The stack frames are part of the stack Starts where static memory ends and grows towards the end of memory Allocated on the program's execution stack Allocated at run time as control flow enters and deallocated as flow exits Managed by the run-time system Dynamic Memory - where the new operator allocates memory and the delete operator deallocates memory during runtime Managed by the programmer (aka the free store) Dynamic memory is stored on the heap Can only have as much physical memory as the machine or OS can make available (mismanaged memory in large programs can lead to it running out of memory and crashing) In classical architectures, the stack and heap grow toward each other to maximize the available space Memory Leaks Occur when a program that allocates memory loses the ability to access the allocated memory Typically due to failure to properly destroy/free dynamically allocated memory that is no longer being used Can cause a program to occupy more and more memory as the program runs, slowing its runtime Can cause a program to fail if memory becomes completely full and additional memory cannot be allocated Programs left running for long periods such as web browsers suffer from known memory leaks Occur at the program level so when the program terminates, all the memory allocated by the program is freed const and pointers A const pointer cannot be changed to point at something else const data cannot be modified char greeting[] = \"Hello\"; char *p = greeting; // non-const pointer, non-const data (unfixed at what it points to & read/write) const char *p = greeting; // non-const pointer, const data (unfixed at what it points to & readonly) const * char p = greeting; // const pointerm, non-const data (fixed at what it points to & read/write) const char * const p = greeting // const pointer, const data (fixed at what it points & readonly) // const anywhere to the left of * means its const data void f1(const Widget *pw) // preferred void f2(Widget const *pw ) // same as above non-const --> const is common const --> non-const is bad and should be avoided this pointer this pointer in a non-const member function of a class X is type: X * const (can change the data of the class but can't change where this is pointing) constant pointer to non-constant object returning objects Objects can be returned from functions Resources (Stack Overflow) Dereferencing Pointers (Reference) Access Operators (Slides) Pointers (Article) Weird Pointer Expressions","title":"Pointers"},{"location":"software_design/pointers/#pointers","text":"A pointer is a variable that contains a memory address as its value Memory address points to the actual data Has a data type that indicates the type of data being stored at the memory address Declared using * operator like: int* a; Refrence/Address Operator: & obtains a variable's memory address Dereference Operator: * retrieves the data at the memory address a pointer stores When declared, pointers hold an unknown address until initialized To indicate pointing at nothing, use nullptr","title":"Pointers"},{"location":"software_design/pointers/#why-use-them","text":"Pointers are all 8-bytes (64-bits on 64-bit machines, 32-bits on 32-bit) so it is much more efficient to use memory addresses of large objects like images or videos than to actually move around the object and make copies of it when doing things like passing them to a function.","title":"Why use them?"},{"location":"software_design/pointers/#common-errors","text":"","title":"Common Errors"},{"location":"software_design/pointers/#syntax","text":"Using the dereference operator when initializing a pointer int* a; int b = 20; *a = &b; // error b/c using derefence operator a = &b // correct The 3rd line is an error b/c *a refers to data being stored at the unknown memory address a was initialized to. This will set the data at a to the memory address of b instead of making a point at b 's memory address. Note this will note cause a compiler error, just a tricky to find bug. However, this is valid and perform the desired functionality because * is not being used for dereferencing but rather declaring a pointer: int b = 20; int *a = &b; Forgetting the * before each pointer when declaring multiple on the same line int* ptr1, ptr2; // ptr1 will be an int pointer but ptr2 will just be an int int *ptr1, *ptr2; // makes both of them int pointers Good practice to declare one pointer per line to avoid this.","title":"Syntax"},{"location":"software_design/pointers/#runtime","text":"Using a derefence operator * when the pointer has not been intialized. This causes undefined behavior meaning the program could crash if the pointer holds an address the program is not allowed to access. Dereferencing a null pointer. This causes the program to crash. Memory overflow can be dangerous b/c it results in overwriting data anywhere in memory (can be OS, other programs, etc.) Aliasing- changing the memory address a pointer points to","title":"Runtime"},{"location":"software_design/pointers/#dereferencing","text":"Derefencing a pointer means accessing the value stored at the memory address the pointer contains char* p = \"abc\" // stores 'a', 'b', 'c' in 3 continuous chunks of memory and p points to the location of a // Pointer arithmetic can be used to access b and c assert(*p == 'a'); // The first character at address p will be 'a' assert(p[1] == 'b'); // p[1] actually dereferences the pointer: p + 1 * (size of p in memory) assert(*(p + 1) == 'b'); // Another notation for p[1] Change data at the address pointed to by derferencing the pointer: *p = 'z' // now the string of chars is zbc assert(*p = 'z') Move pointers through the data: ++p; // Increment p so now it points to 'b' assert(*p == 'b');","title":"Dereferencing"},{"location":"software_design/pointers/#member-access-operator","text":"struct SomeStruct {int a;}; SomeStruct s; SomeStruct* structPtr = s; structPtr->a = 1; // is cleaner than: (*structPtr).a = 1;","title":"Member Access Operator"},{"location":"software_design/pointers/#arrays","text":"Represented internally as a pointer to the first element Accessing elements using indexing is actually just using pointer arithmetic A variable declared as an array is the same as a variable declared as a pointer When passing an array to a function, only the address of the array is copied into the parameter so any changes to the array in the function will cause a change to the original array b/c its shared void f1(int array[]) = void f1(int *array) [] and * are effectively the same but [] provides better documentation/readability Array of pointers (multi-dimensional arrays): ** or *[] can be used to declare arrays of pointers Allows a program to contain elements that vary in size (saves memory which is important for programs using large data objects)","title":"Arrays"},{"location":"software_design/pointers/#strings","text":"represented internally as a character array ending with the null character \\0 since it is a character array, pointer arithmetic and everything can be done on strings","title":"Strings"},{"location":"software_design/pointers/#const","text":"const ensures data cannot be modified and the compiler will enforce this constraint Use as much as possible const int num; num = 10; // error! const char let = 'a'; // good! let = 'b'; // error","title":"Const"},{"location":"software_design/pointers/#new-and-delete-operators","text":"new allocates memory for the given type and returns a pointer to the allocated memory If the type is a class, it calls the constructor after allocating memory for the class's data members Can pass arguments to the constructor by passing them in parentheses after the class name (ex: ClassA a = new ClassA(\"Test\") ) To allocate a continuous chunk of memory for an array of objects use new SomeClass[size] Default constructor called for each object in array (class must have a constructor that can take 0 arguments otherwise a compiler error will occur) delete deallocates/frees a block of memory allocated with new No effect if used on nullptr Dereferencing after using delete will cause undefined behavior if pointer is not set to nullptr Calling delete on pointer not allocated with new has undefined behavior and is a logic error Must be called on a pointer to memory allocated using new Doesn't set a pointer to nullptr just frees the memory (must be done manually) To delete an array of objects use delete[] array Calling destructor instead of delete fails to actually free up the memory","title":"New and Delete Operators"},{"location":"software_design/pointers/#memory-regions","text":"Memory has 3 different regions: data, stack, and heap. There are 3 types of memory allocation: static, dynamic, and automatic A program's memory usage includes 3 different regions: Static - global & static local variables are allocated at compilation time (fixed size) Reserved at compile time in the program's data segment Allocated as a fixed block of memory Stores any global and static local variables Stores the actual code Allocated when program starts and deallocated when program exists Automatic - each function call allocates a new block of memory called a stack frame to holds its local variables. The stack frames are part of the stack Starts where static memory ends and grows towards the end of memory Allocated on the program's execution stack Allocated at run time as control flow enters and deallocated as flow exits Managed by the run-time system Dynamic Memory - where the new operator allocates memory and the delete operator deallocates memory during runtime Managed by the programmer (aka the free store) Dynamic memory is stored on the heap Can only have as much physical memory as the machine or OS can make available (mismanaged memory in large programs can lead to it running out of memory and crashing) In classical architectures, the stack and heap grow toward each other to maximize the available space","title":"Memory Regions"},{"location":"software_design/pointers/#memory-leaks","text":"Occur when a program that allocates memory loses the ability to access the allocated memory Typically due to failure to properly destroy/free dynamically allocated memory that is no longer being used Can cause a program to occupy more and more memory as the program runs, slowing its runtime Can cause a program to fail if memory becomes completely full and additional memory cannot be allocated Programs left running for long periods such as web browsers suffer from known memory leaks Occur at the program level so when the program terminates, all the memory allocated by the program is freed","title":"Memory Leaks"},{"location":"software_design/pointers/#const-and-pointers","text":"A const pointer cannot be changed to point at something else const data cannot be modified char greeting[] = \"Hello\"; char *p = greeting; // non-const pointer, non-const data (unfixed at what it points to & read/write) const char *p = greeting; // non-const pointer, const data (unfixed at what it points to & readonly) const * char p = greeting; // const pointerm, non-const data (fixed at what it points to & read/write) const char * const p = greeting // const pointer, const data (fixed at what it points & readonly) // const anywhere to the left of * means its const data void f1(const Widget *pw) // preferred void f2(Widget const *pw ) // same as above non-const --> const is common const --> non-const is bad and should be avoided","title":"const and pointers"},{"location":"software_design/pointers/#this-pointer","text":"this pointer in a non-const member function of a class X is type: X * const (can change the data of the class but can't change where this is pointing) constant pointer to non-constant object","title":"this pointer"},{"location":"software_design/pointers/#returning-objects","text":"Objects can be returned from functions","title":"returning objects"},{"location":"software_design/pointers/#resources","text":"(Stack Overflow) Dereferencing Pointers (Reference) Access Operators (Slides) Pointers (Article) Weird Pointer Expressions","title":"Resources"},{"location":"software_design/smart-pointers/","text":"Smart Pointers Class type that look and act like a raw pointer but with additional capabilities Allows programmer to control the following pointer behaviors: Construction and Destruction: Copy and assignment Shallow copy, deep copy, or no copy Dereferencing Primarily used for RAII to make programs using pointers exception safe unique_ptr Smart pointer that cleans up after itself Advantages: Very efficient When it goes out of scope, the destructor frees pointed to object Disadvantages: Retains sole ownership of an objct Cannot copy or copy-assign Two instances cannot manage the same object Typical uses: Guarantees deletion (helpful for exception safety) Passing ownership of uniquely-owned objects into methods Acquiring ownership of uniquely-owned objects from methods Managing ownership: release() reset() swap() Can be used w/ arrays shared_ptr reference-counting smart pointer Track how many objects point to a particular resource Deletes the resource when no pointers point to the resource anymore assignment and copy construction are how shared_ptrs keep track of the number of references constructing the pointers seperately would result in two different shared_ptrs using std::shared_ptr; Circle *foo = new Circle(); shared_ptr<Shape> aShape(foo); shared_ptr<Shape> aNewShape(aShape) // copy constructor creates new smart pointer and increments reference count aShape = aNewShape; // nothing changes shared_ptr<Shape> aNewPtr(foo); // creates an entirely new shared_ptr with seperate reference count than the above shared_ptrs","title":"Smart Pointers"},{"location":"software_design/smart-pointers/#smart-pointers","text":"Class type that look and act like a raw pointer but with additional capabilities Allows programmer to control the following pointer behaviors: Construction and Destruction: Copy and assignment Shallow copy, deep copy, or no copy Dereferencing Primarily used for RAII to make programs using pointers exception safe","title":"Smart Pointers"},{"location":"software_design/smart-pointers/#unique_ptr","text":"Smart pointer that cleans up after itself Advantages: Very efficient When it goes out of scope, the destructor frees pointed to object Disadvantages: Retains sole ownership of an objct Cannot copy or copy-assign Two instances cannot manage the same object Typical uses: Guarantees deletion (helpful for exception safety) Passing ownership of uniquely-owned objects into methods Acquiring ownership of uniquely-owned objects from methods Managing ownership: release() reset() swap() Can be used w/ arrays","title":"unique_ptr"},{"location":"software_design/smart-pointers/#shared_ptr","text":"reference-counting smart pointer Track how many objects point to a particular resource Deletes the resource when no pointers point to the resource anymore assignment and copy construction are how shared_ptrs keep track of the number of references constructing the pointers seperately would result in two different shared_ptrs using std::shared_ptr; Circle *foo = new Circle(); shared_ptr<Shape> aShape(foo); shared_ptr<Shape> aNewShape(aShape) // copy constructor creates new smart pointer and increments reference count aShape = aNewShape; // nothing changes shared_ptr<Shape> aNewPtr(foo); // creates an entirely new shared_ptr with seperate reference count than the above shared_ptrs","title":"shared_ptr"},{"location":"software_design/stl/","text":"Standard Template Library Contains generic template classes and functions for containers, iterators, & algorithms Allows for development of generic programs that are independent of the underlying container STL Containers Are abstract data types (ADTs) that hold data for manipulation 3 types 1) Sequential - arrange data in a linear manner vector, deque, list 2) Associative - maintain data in structures suitable for fast associative operations set, multiset, map, multimap Implemented as balanced binary trees Supports efficient operations on elements using keys ordered by operator< Provide efficient, direct accessto store and retrieve elements via a key Keys are maintained in ascending order 3) Adaptors - provide different ways to access sequential and associative containers stack, queue, priority queue vector Can change size dynamically (resizable array) Provides best random-access performance Supports random access iterator Insertions/deletions at the back of the vector ( push_back() and pop_back() ) push_back - used when we can only copy emplace_back - used when we do not need to copy for speed increase Pros: Const time access elements by index Linear time iteration over all elements Const amortized (avg) time for adding/removing elements from the end O(N)/N Cons: consume more memory than arrays due to automatic resizing Memory is gauranteed to be contiguous so can use pointer arithmetic deque Pronounced \"deck\" Double ended queue Advantages: Provides efficient index access to data Efficient insertions/deletions at both front and back of queue push_back() , push_front() , pop_back() , pop_front() Uses a index lookup table to optimize memory and lookup efficiency Vector will be slightly faster b/c it doesnt need the lookup table due to only pushing back Elements not guaranteeed to be in contiguous storage locations so pointer arithmetic not safe list Implements a doubly linked-list Advantages: Const time insertion/removal of elements anywhere in the container Const time moving elements and blocks of elements within the container or even between different containers It just requires pointer assignments instead of copying values and allocating new arrays Disadvantages: No support for random-access iterator set provides rapid look-up but does not permit duplicates O(logn) amortized time complexity for insertion and deletion Because its stored as a balanced binary tree- usually a red-black tree // Create an output stream iterator with \" \" as a delimeter std::ostream_iterator<double> output(std::cout, \" \"); std::set<double> doubleSet; // insert on a set returns a pair: an iterator to the value and T if it was inserted, F if it already existed std::pair<std::set<double>::const_iterator, bool> pairValue; pairValue = doubleSet.insert(13.2) // or simply use auto to infer the type auto pairValue = doubleSet.insert(13.2) std::cout << *(pairValue.first) << (pairValue.second ? \"was\" : \"was not\") << \"inserted\" << std::endl; std::cout << \"Set contains: \"; std::copy(doubleSet.begin(),doubleSet.end(),output); multiset provides rapid look-up but permits duplicates Order of data determined by a comparator function std::multiset<int> intMultiSet; // insert on a multiset just returns an iterator intMultiSet.insert(1); // check for an item if (intMultiSet.find(2) == intMultiSet.end()) std::cout << \"Not found\" map Provides lookup using a rapid key based lookup Each value is associated with a unique key (no duplicate keys) AKA associative array Implemented as either a hashtable or red-black tree depending on the compiler multimap Allows duplicate keys No index operator notation since ambiguity in which key is being referred to","title":"STL"},{"location":"software_design/stl/#standard-template-library","text":"Contains generic template classes and functions for containers, iterators, & algorithms Allows for development of generic programs that are independent of the underlying container","title":"Standard Template Library"},{"location":"software_design/stl/#stl-containers","text":"Are abstract data types (ADTs) that hold data for manipulation 3 types 1) Sequential - arrange data in a linear manner vector, deque, list 2) Associative - maintain data in structures suitable for fast associative operations set, multiset, map, multimap Implemented as balanced binary trees Supports efficient operations on elements using keys ordered by operator< Provide efficient, direct accessto store and retrieve elements via a key Keys are maintained in ascending order 3) Adaptors - provide different ways to access sequential and associative containers stack, queue, priority queue","title":"STL Containers"},{"location":"software_design/stl/#vector","text":"Can change size dynamically (resizable array) Provides best random-access performance Supports random access iterator Insertions/deletions at the back of the vector ( push_back() and pop_back() ) push_back - used when we can only copy emplace_back - used when we do not need to copy for speed increase Pros: Const time access elements by index Linear time iteration over all elements Const amortized (avg) time for adding/removing elements from the end O(N)/N Cons: consume more memory than arrays due to automatic resizing Memory is gauranteed to be contiguous so can use pointer arithmetic","title":"vector"},{"location":"software_design/stl/#deque","text":"Pronounced \"deck\" Double ended queue Advantages: Provides efficient index access to data Efficient insertions/deletions at both front and back of queue push_back() , push_front() , pop_back() , pop_front() Uses a index lookup table to optimize memory and lookup efficiency Vector will be slightly faster b/c it doesnt need the lookup table due to only pushing back Elements not guaranteeed to be in contiguous storage locations so pointer arithmetic not safe","title":"deque"},{"location":"software_design/stl/#list","text":"Implements a doubly linked-list Advantages: Const time insertion/removal of elements anywhere in the container Const time moving elements and blocks of elements within the container or even between different containers It just requires pointer assignments instead of copying values and allocating new arrays Disadvantages: No support for random-access iterator","title":"list"},{"location":"software_design/stl/#set","text":"provides rapid look-up but does not permit duplicates O(logn) amortized time complexity for insertion and deletion Because its stored as a balanced binary tree- usually a red-black tree // Create an output stream iterator with \" \" as a delimeter std::ostream_iterator<double> output(std::cout, \" \"); std::set<double> doubleSet; // insert on a set returns a pair: an iterator to the value and T if it was inserted, F if it already existed std::pair<std::set<double>::const_iterator, bool> pairValue; pairValue = doubleSet.insert(13.2) // or simply use auto to infer the type auto pairValue = doubleSet.insert(13.2) std::cout << *(pairValue.first) << (pairValue.second ? \"was\" : \"was not\") << \"inserted\" << std::endl; std::cout << \"Set contains: \"; std::copy(doubleSet.begin(),doubleSet.end(),output);","title":"set"},{"location":"software_design/stl/#multiset","text":"provides rapid look-up but permits duplicates Order of data determined by a comparator function std::multiset<int> intMultiSet; // insert on a multiset just returns an iterator intMultiSet.insert(1); // check for an item if (intMultiSet.find(2) == intMultiSet.end()) std::cout << \"Not found\"","title":"multiset"},{"location":"software_design/stl/#map","text":"Provides lookup using a rapid key based lookup Each value is associated with a unique key (no duplicate keys) AKA associative array Implemented as either a hashtable or red-black tree depending on the compiler","title":"map"},{"location":"software_design/stl/#multimap","text":"Allows duplicate keys No index operator notation since ambiguity in which key is being referred to","title":"multimap"},{"location":"software_design/strong-exception-safety/","text":"Strong Exception Safety Very large and old software systems with ad hoc resource managment cannot use exceptions Noexcept Specfication Functions that guarantee they will not throw an exception should specify that like so: void foo (...) noexcept; Can also be used as an operator that returns true at compile time if a given expression is guaranteed to not throw an exception delete , return and std::swap are all noexcept General Principles Can design every function to: 1) Complete successfully 2) Fail in a well-defined manner Assume every function that can throw an exception will throw one and incorporate it into your code/design Never delete a peice of information before the replacement info is ready for use Basic Tools: Try-blocks Support from Resource Acquisition Is Initialization (RAII) technique Throw and catch exceptions only when absolutely necessary When exception is thrown: Leak no resources Don't permit data structures to become corrupted Golden Rule: when an exception is propagated, try to leave the object in the state it had when the function was called Avoid side effects in expressions that may propagate exceptions Standard Exception Class Heierarchy exception logic_error domain_error length_error invalid_argument out_of_range runtime_error range_error overflow_error underflow_error Mutex Mu tual ex clusion object An object that allows multiple program threads to share the same resource (e.g. file access) but not simultaneously Mutex is locked when being used and unlocked when no longer needed std::lock_guard<std::mutex> mutex(exMutex) will automatically lock and unlock the mutex when Strong exception safety because mutex will be unlocked if exception is thrown and will not freeze program b/c of never reaching the unlock call Example of using RAII to destroy local variables when they go out of scope Exception Safety Exception safe functions provide one of four guarantees for if an exception is thrown: No Safety- code is in bad place Weak/Basic- everything in function remains in a valid state, but exact state may be unknown Strong- state of program is unchanged Nothrow- function always works and never throws an exception Arithmetic operations on primitive types do not throw exceptions delete is no throw because we need to be able to reliably delete things For same reason, destructors should be nothrow Operating overloading can cause exceptions on user defined types because they are function calls Combining operating overloading with templates makes things very complicated since depending on whether the type is a primitive or user defined, exceptions may be possible with simple operator calls Resource Acquisition Is Initialization (RAII) Only code guaranteed to be executed after an exception is thrown are the destructors of objects residing on the stack (local variables) Vital to writing exception safe C++ code Required so that resources are released before permitting exceptions to propagate (in order to avoid resource leaks) Source code of std::lock_gaurd demonstrating wrapping a resource in a class that can be used as a local variable so that its destructor is called when exceptions are thrown and the resource is properly dealt with: namespace std{ template <typename MUTEX> class lock_gaurd { public: lock_guard(MUTEX &m) : m(m) {m.lock();} ~lock_guard() {m.unlock();} private: MUTEX &m; } } RAII is used with strings, vectors, list, etc. std::shared_ptr and std::unique_ptr is the same concept and is a local variable that destroys what is being pointed to when they go out of scope Exception Handling Guidlines always rethrow an exception caught in catch(...) if another catch can deal with the exception Don't strip info from the exception and","title":"Strong Exception Safety"},{"location":"software_design/strong-exception-safety/#strong-exception-safety","text":"Very large and old software systems with ad hoc resource managment cannot use exceptions","title":"Strong Exception Safety"},{"location":"software_design/strong-exception-safety/#noexcept-specfication","text":"Functions that guarantee they will not throw an exception should specify that like so: void foo (...) noexcept; Can also be used as an operator that returns true at compile time if a given expression is guaranteed to not throw an exception delete , return and std::swap are all noexcept","title":"Noexcept Specfication"},{"location":"software_design/strong-exception-safety/#general-principles","text":"Can design every function to: 1) Complete successfully 2) Fail in a well-defined manner Assume every function that can throw an exception will throw one and incorporate it into your code/design Never delete a peice of information before the replacement info is ready for use Basic Tools: Try-blocks Support from Resource Acquisition Is Initialization (RAII) technique Throw and catch exceptions only when absolutely necessary When exception is thrown: Leak no resources Don't permit data structures to become corrupted Golden Rule: when an exception is propagated, try to leave the object in the state it had when the function was called Avoid side effects in expressions that may propagate exceptions","title":"General Principles"},{"location":"software_design/strong-exception-safety/#standard-exception-class-heierarchy","text":"exception logic_error domain_error length_error invalid_argument out_of_range runtime_error range_error overflow_error underflow_error","title":"Standard Exception Class Heierarchy"},{"location":"software_design/strong-exception-safety/#mutex","text":"Mu tual ex clusion object An object that allows multiple program threads to share the same resource (e.g. file access) but not simultaneously Mutex is locked when being used and unlocked when no longer needed std::lock_guard<std::mutex> mutex(exMutex) will automatically lock and unlock the mutex when Strong exception safety because mutex will be unlocked if exception is thrown and will not freeze program b/c of never reaching the unlock call Example of using RAII to destroy local variables when they go out of scope","title":"Mutex"},{"location":"software_design/strong-exception-safety/#exception-safety","text":"Exception safe functions provide one of four guarantees for if an exception is thrown: No Safety- code is in bad place Weak/Basic- everything in function remains in a valid state, but exact state may be unknown Strong- state of program is unchanged Nothrow- function always works and never throws an exception Arithmetic operations on primitive types do not throw exceptions delete is no throw because we need to be able to reliably delete things For same reason, destructors should be nothrow Operating overloading can cause exceptions on user defined types because they are function calls Combining operating overloading with templates makes things very complicated since depending on whether the type is a primitive or user defined, exceptions may be possible with simple operator calls","title":"Exception Safety"},{"location":"software_design/strong-exception-safety/#resource-acquisition-is-initialization-raii","text":"Only code guaranteed to be executed after an exception is thrown are the destructors of objects residing on the stack (local variables) Vital to writing exception safe C++ code Required so that resources are released before permitting exceptions to propagate (in order to avoid resource leaks) Source code of std::lock_gaurd demonstrating wrapping a resource in a class that can be used as a local variable so that its destructor is called when exceptions are thrown and the resource is properly dealt with: namespace std{ template <typename MUTEX> class lock_gaurd { public: lock_guard(MUTEX &m) : m(m) {m.lock();} ~lock_guard() {m.unlock();} private: MUTEX &m; } } RAII is used with strings, vectors, list, etc. std::shared_ptr and std::unique_ptr is the same concept and is a local variable that destroys what is being pointed to when they go out of scope","title":"Resource Acquisition Is Initialization (RAII)"},{"location":"software_design/strong-exception-safety/#exception-handling-guidlines","text":"always rethrow an exception caught in catch(...) if another catch can deal with the exception Don't strip info from the exception and","title":"Exception Handling Guidlines"},{"location":"software_design/templates/","text":"Templates Permit the definition of a template class or template function that can be used with multiple data types Requires only a single definition Permits reuse Compiler will create specific versions when functions are used with specific types Save time and avoid code replication One class template that is instantiated for N specific classes with X associated member functions Instead of writing N * X member functions, you only write X Can result in code bloat (source code looks small but object code/binaries are large) Need to be recompiled for each translation unit (can dramatically increase compile time) Need to do a commonality and variability analysis Look for replication to idenfity when a template could instead be instantiated multiple times Function Templates Define a specific behavior that can be applied to any data type Method overloading can be used to provide functionality for each data type Parameters and return type may be template types template <typename T> void functionName(T paramName, ...){ ... } When program runs and a call to the function template is encountered: 1) compiler substitutes the appropriate type(s) for the template params 2) compiler compiles this version of the function Multiple copies of function templates are created (one for each data type used) Function templates : specify a range of related functinos with a single code segment Written by programmer Template functions : the individually compiled versions of the function tempalte Generated by compiler Class Templates Allow the program to contain a generic class definition that can be instantiated into a type specific object cpp files for template classes cannot be compiled on their own Need to have types inserted to be compiled (must create an object to compile a template class) .h file for the template class will #include '<name>.cpp' So the template's cpp file should be left out of the CMake list Seperating interface from the implementation is good practice Common way is to implement everything in the .h for template classes (will see this in libraries often) Can pass a literal as a template parameter such as the int parameter below: // ClassName.h file template<typename T, typename T2, int x> class ClassName { public: ... private: ... } // ClassName.cpp file template<typename T, typename T2, > ClassName<T, T2, X>::ClassName(...) { .. } ... // main.cpp file int main() { ClassName<datatype, datatypeT2, int> objectName(); ... } Class templates : specify a range of related classes with a single definition (not compileable) Defined by programmer Template classes : the individual instantiated versions of the class template that are compileable Created by compiler Can set defaults types or values for template parameters: template<typename T=int, int x=10> Template classes Can be used as arguments to other templates since they are valid types once compiled Compiler doesn't evaluate class templates unless they are used (methods could be uncompiled if class not instantiated) Specialization In the below version, a seperate version of sum() is provided for string types while the generic template version of sum() is provided for other types. This reduces code bloat b/c only the necessary implementation will be compiled if a class of that type is instantiated You can specialize a method as many times as needed A non-specialized version should still be provided as well template <> std::string Stack<std::string>::sum() const { std::string value; for (uint32_t i = 0; i < stackTop; ++i) { value = stack[i] + value; } return value; } template <typename T> T Stack<T>::sum() const { T value = T(); for (uint32_t i = 0; i < stackTop; ++i) { value += stack[i]; } return value; }","title":"Templates"},{"location":"software_design/templates/#templates","text":"Permit the definition of a template class or template function that can be used with multiple data types Requires only a single definition Permits reuse Compiler will create specific versions when functions are used with specific types Save time and avoid code replication One class template that is instantiated for N specific classes with X associated member functions Instead of writing N * X member functions, you only write X Can result in code bloat (source code looks small but object code/binaries are large) Need to be recompiled for each translation unit (can dramatically increase compile time) Need to do a commonality and variability analysis Look for replication to idenfity when a template could instead be instantiated multiple times","title":"Templates"},{"location":"software_design/templates/#function-templates","text":"Define a specific behavior that can be applied to any data type Method overloading can be used to provide functionality for each data type Parameters and return type may be template types template <typename T> void functionName(T paramName, ...){ ... } When program runs and a call to the function template is encountered: 1) compiler substitutes the appropriate type(s) for the template params 2) compiler compiles this version of the function Multiple copies of function templates are created (one for each data type used) Function templates : specify a range of related functinos with a single code segment Written by programmer Template functions : the individually compiled versions of the function tempalte Generated by compiler","title":"Function Templates"},{"location":"software_design/templates/#class-templates","text":"Allow the program to contain a generic class definition that can be instantiated into a type specific object cpp files for template classes cannot be compiled on their own Need to have types inserted to be compiled (must create an object to compile a template class) .h file for the template class will #include '<name>.cpp' So the template's cpp file should be left out of the CMake list Seperating interface from the implementation is good practice Common way is to implement everything in the .h for template classes (will see this in libraries often) Can pass a literal as a template parameter such as the int parameter below: // ClassName.h file template<typename T, typename T2, int x> class ClassName { public: ... private: ... } // ClassName.cpp file template<typename T, typename T2, > ClassName<T, T2, X>::ClassName(...) { .. } ... // main.cpp file int main() { ClassName<datatype, datatypeT2, int> objectName(); ... } Class templates : specify a range of related classes with a single definition (not compileable) Defined by programmer Template classes : the individual instantiated versions of the class template that are compileable Created by compiler Can set defaults types or values for template parameters: template<typename T=int, int x=10> Template classes Can be used as arguments to other templates since they are valid types once compiled Compiler doesn't evaluate class templates unless they are used (methods could be uncompiled if class not instantiated)","title":"Class Templates"},{"location":"software_design/templates/#specialization","text":"In the below version, a seperate version of sum() is provided for string types while the generic template version of sum() is provided for other types. This reduces code bloat b/c only the necessary implementation will be compiled if a class of that type is instantiated You can specialize a method as many times as needed A non-specialized version should still be provided as well template <> std::string Stack<std::string>::sum() const { std::string value; for (uint32_t i = 0; i < stackTop; ++i) { value = stack[i] + value; } return value; } template <typename T> T Stack<T>::sum() const { T value = T(); for (uint32_t i = 0; i < stackTop; ++i) { value += stack[i]; } return value; }","title":"Specialization"},{"location":"system_design/docker/","text":"Docker Tool for running applications in an isolated environment Advantages : Same environment (Works on all computers if it works on docker) Sandbox Projects (Keeps them separate: no conflicts & better security) Simple to get started on others' projects Containers : the building blocks of Docker Stop by themselves when the main process finishes/exits (e.g. php or node.js dies) Should be one process per container b/c the life of the container is tied to that process Lightweight so lots of containers can be run on a computer at a time Docker vs. Virutal Machines Docker is less resource heavy than a virtual machine so it is faster than a VM Docker Images A Dockerfile is a file with a list of steps to create the image A Docker Image is a template for creating a desired environment and includes an OS, software, and application code A Docker Container is a running instance of a docker image Setting up a Docker Project Create Dockerfile in the root of the project/services directory (outside src folder) Where we will start from an existing image and build on top of it Can find thousands of images on Dockerhub Write the instructions to build your image in the Dockerfile FROM specifies the starting/base image to be downloaded from Dockerhub (Must be the 1st line) COPY copies the files from the first directory to the second location inside the image (specified in image's documentation) EXPOSE tells running containers to listen on the specified port FROM php:7-0-apache COPY src/ /var/www/html EXPOSE 80 Build the docker image from the terminal -t image-name specifies the image's name location is the path to the Dockerfile which is . if in the same directory docker build -t image-name location Run the docker container from the terminal -p 80:80 forwards port 80 in the host to port 80 in the container which was exposed in the docker file, allowing it to accept the request so that the code in the container can handle the request docker run -p 80:80 image-name Volumes One type allows the sharing of data between containers The other type allows the sharing of folders between the host and the container Useful for development since any changes to source code doesn't require a new image to be built and new container to be spun up Will need to rebuild the image to deploy it to somewhere else b/c volumes just give the ability for a container to see files on the host's filesystem, volumes don't change the image Building an image from a Dockerfile copies the src code so that it can be deployed elsewhere Mounting a volume is done when running the container Must use absolute paths of folders to be mounted docker run -p80:80 -v /Users/admin/project/src/:/var/www/html/ image-name Extra: FROM python:3-onbuild COPY . /usr/src/app CMD [\"python\",\"api.py\"] Docker Compose Lets you define all you services/containers in a configuration file With one command, all the containers can be spun up The configuration files save the hassel of writing the docker run commands for each container with all their specifications for volumes and ports Creates a virtual network for all the containers allowing communication for all the containers specified in the docker-compose file The host names of the containers match the service names defined in docker-compose.yml Setting up a Project w/ Docker Compose Create docker-compose.yml in root directory of project Write the configuration instructions in docker-compose.yml Directories are relative to where the docker-compose file is version specifies the version of docker-compose file format that you will be writing in (the formats are often updated so this helps specify what syntax you will be using) build takes ther relative path to the Dockerfile for a container volumes & ports allows you to list the volumes and ports for that docker image depends_on allows you to specify other services necessary for the service to run version: '3' services: product-service: build: ./product volumes: - ./product:/usr/src/app ports: - 5001:80 website: image: php:apache volumes: - ./website:/var/www/html ports: - 5000:80 depends_on: - product-service Spin up the containers running docker-compose up from the terminal from the directory where the docker-compose file is located Will build all the images and then run all the containers Running docker-compose up -d will spin up the containers in detached mode meaning you can continue working on the terminal run docker ps to see the status of the containers in detached mode run docker-compose stop to stop the containers in detached mode (ctr + c works in nondetached mode)","title":"Docker"},{"location":"system_design/docker/#docker","text":"Tool for running applications in an isolated environment Advantages : Same environment (Works on all computers if it works on docker) Sandbox Projects (Keeps them separate: no conflicts & better security) Simple to get started on others' projects Containers : the building blocks of Docker Stop by themselves when the main process finishes/exits (e.g. php or node.js dies) Should be one process per container b/c the life of the container is tied to that process Lightweight so lots of containers can be run on a computer at a time","title":"Docker"},{"location":"system_design/docker/#docker-vs-virutal-machines","text":"Docker is less resource heavy than a virtual machine so it is faster than a VM","title":"Docker vs. Virutal Machines"},{"location":"system_design/docker/#docker-images","text":"A Dockerfile is a file with a list of steps to create the image A Docker Image is a template for creating a desired environment and includes an OS, software, and application code A Docker Container is a running instance of a docker image","title":"Docker Images"},{"location":"system_design/docker/#setting-up-a-docker-project","text":"Create Dockerfile in the root of the project/services directory (outside src folder) Where we will start from an existing image and build on top of it Can find thousands of images on Dockerhub Write the instructions to build your image in the Dockerfile FROM specifies the starting/base image to be downloaded from Dockerhub (Must be the 1st line) COPY copies the files from the first directory to the second location inside the image (specified in image's documentation) EXPOSE tells running containers to listen on the specified port FROM php:7-0-apache COPY src/ /var/www/html EXPOSE 80 Build the docker image from the terminal -t image-name specifies the image's name location is the path to the Dockerfile which is . if in the same directory docker build -t image-name location Run the docker container from the terminal -p 80:80 forwards port 80 in the host to port 80 in the container which was exposed in the docker file, allowing it to accept the request so that the code in the container can handle the request docker run -p 80:80 image-name","title":"Setting up a Docker Project"},{"location":"system_design/docker/#volumes","text":"One type allows the sharing of data between containers The other type allows the sharing of folders between the host and the container Useful for development since any changes to source code doesn't require a new image to be built and new container to be spun up Will need to rebuild the image to deploy it to somewhere else b/c volumes just give the ability for a container to see files on the host's filesystem, volumes don't change the image Building an image from a Dockerfile copies the src code so that it can be deployed elsewhere Mounting a volume is done when running the container Must use absolute paths of folders to be mounted docker run -p80:80 -v /Users/admin/project/src/:/var/www/html/ image-name","title":"Volumes"},{"location":"system_design/docker/#extra","text":"FROM python:3-onbuild COPY . /usr/src/app CMD [\"python\",\"api.py\"]","title":"Extra:"},{"location":"system_design/docker/#docker-compose","text":"Lets you define all you services/containers in a configuration file With one command, all the containers can be spun up The configuration files save the hassel of writing the docker run commands for each container with all their specifications for volumes and ports Creates a virtual network for all the containers allowing communication for all the containers specified in the docker-compose file The host names of the containers match the service names defined in docker-compose.yml","title":"Docker Compose"},{"location":"system_design/docker/#setting-up-a-project-w-docker-compose","text":"Create docker-compose.yml in root directory of project Write the configuration instructions in docker-compose.yml Directories are relative to where the docker-compose file is version specifies the version of docker-compose file format that you will be writing in (the formats are often updated so this helps specify what syntax you will be using) build takes ther relative path to the Dockerfile for a container volumes & ports allows you to list the volumes and ports for that docker image depends_on allows you to specify other services necessary for the service to run version: '3' services: product-service: build: ./product volumes: - ./product:/usr/src/app ports: - 5001:80 website: image: php:apache volumes: - ./website:/var/www/html ports: - 5000:80 depends_on: - product-service Spin up the containers running docker-compose up from the terminal from the directory where the docker-compose file is located Will build all the images and then run all the containers Running docker-compose up -d will spin up the containers in detached mode meaning you can continue working on the terminal run docker ps to see the status of the containers in detached mode run docker-compose stop to stop the containers in detached mode (ctr + c works in nondetached mode)","title":"Setting up a Project w/ Docker Compose"},{"location":"system_design/microservices/","text":"Microservice Architectual Style: Developing a single application as a suite of small services, each running in its own process and communicating with lightweight mechanics, often an HTTP resource API Encourages modularity and seperation of concerns ability to horizontally scale and partition the workload Microservices contain many aspects in reality: Clients, Caches, and Databases are all included in a microservice in conjuction with the service itself Stateless Service: Not a cache or database Frequently accessed metadata no instance affinity Losing a node is not a big deal and can be easily fixed Stateful Service: Databases & caches Custom apps which holds lots of data Losing a node is a notable event and it might take hours to get it fixed","title":"Microservices"},{"location":"system_design/microservices/#microservice-architectual-style","text":"Developing a single application as a suite of small services, each running in its own process and communicating with lightweight mechanics, often an HTTP resource API Encourages modularity and seperation of concerns ability to horizontally scale and partition the workload Microservices contain many aspects in reality: Clients, Caches, and Databases are all included in a microservice in conjuction with the service itself","title":"Microservice Architectual Style:"},{"location":"system_design/microservices/#stateless-service","text":"Not a cache or database Frequently accessed metadata no instance affinity Losing a node is not a big deal and can be easily fixed","title":"Stateless Service:"},{"location":"system_design/microservices/#stateful-service","text":"Databases & caches Custom apps which holds lots of data Losing a node is a notable event and it might take hours to get it fixed","title":"Stateful Service:"},{"location":"web_dev/html-css/sass/","text":"Sass h1, h2, h3 { //Equivalent to h1.lg-heading &.lg-heading{} //Affects any nested elements w/in h1/h2/h3 with the specified class name .lg-heading{} } 6rem is 6 times the rem unit rem unit is a multiplier of the html tag's font size (default is 16 pixels) z-index is how close an element is to you (layering) //Allows the same transition to be used uniformly throughout a file @mixin easeOut(){ transition: all 0.5s ease-out; } a { //& uses the element it is nested in &:hover { color: $secondary-color @include easeOut(); } } vh & vw slice the screen into numerous slices of height and width 100 vh and 100 vw takes up whole screen 10 vh takes 10 slices of the height rgba(color,opacity) Sets the color and opacity for a property stands for red green blue alpha","title":"Sass"},{"location":"web_dev/html-css/sass/#sass","text":"h1, h2, h3 { //Equivalent to h1.lg-heading &.lg-heading{} //Affects any nested elements w/in h1/h2/h3 with the specified class name .lg-heading{} } 6rem is 6 times the rem unit rem unit is a multiplier of the html tag's font size (default is 16 pixels) z-index is how close an element is to you (layering) //Allows the same transition to be used uniformly throughout a file @mixin easeOut(){ transition: all 0.5s ease-out; } a { //& uses the element it is nested in &:hover { color: $secondary-color @include easeOut(); } } vh & vw slice the screen into numerous slices of height and width 100 vh and 100 vw takes up whole screen 10 vh takes 10 slices of the height rgba(color,opacity) Sets the color and opacity for a property stands for red green blue alpha","title":"Sass"},{"location":"web_dev/js/basics/","text":"What is JavaScript Dynamic Programming Language (operations done at run-time) E.g. Possible to change variable type or add new properties/methods to an object while the program is running Dynamically-Typed Language (Interpreter assigns variables a type at runtime based on its current value) Can provide interactivity on websites when applied to an html document Interpreted language (Doesn't have to be compiled) Runs on the client's computer/browser Object Based Prototype based instead of class based like Java Scripting language (lightweight) Uses for JavaScript: Put content in an HTML page on the fly Make webpages responsive Detect a user's browser and other info Create cookies Validate forms Create animations, slideshows, scrollers, etc Build apps w/ JS frameworks (ex: angularJS, reactJS, etc) Primitive Data Types Number- integers and decimals String- use single or double quotes (single preferred) .length property Boolean- true or false Null- intentional absence of a value represnted by null Undefined- absence of a valuae represented by undefined and is different than null Symbol- unique identifiers and useful in more complex coding Variables When declaring variables without assigning a value, their inital value is set to undefined Prior to ES6, var was the only keyword to declare variables ( More Info ) Variables declared using var are created before any code is executed in a process known as hoisting A variable's initial value is undefined and its actual value is intialized when the assignment statement is reached in execution This means a variable can be used before it is declared in the code since hoisting results in the equivalent of all variables being declared at the top In ES6, let and const were introduced let signals that the variable can be reassigned a different value const signals that the variable is a constant and cannot be reassigned Reassigning a const will throw a TypeError Variables can be transformed using mathematical asignment operators ( += , *= , /= ) and increment/decrement operators ( ++ , -- ) In ES6, we can insert (or interpolate) variables into strings using template literals Uses backticks instead of single/double quotes const myPet = 'armadillo'; console.log(`I own a pet ${myPet}`); // Output: I own a pet armadillo. typeof operator will return a string of the data type of the value to its right (e.g. typeof 'hello' returns 'string') Conditional Statements if (greeting) { console.log('Hello World!') } else if (goodbye){ console.log('Bye World!') } else { console.log('IDK') } Comparison Operators: < , > , <= , >= , === , !== Don't use == or != b/c types are not considered (Read More) Logical Operators: and && , or || , not: ! Values that are not explicitly true/false but evaluate to true/false are called truthy/falsy Falsy: 0 ,empty strings, null , undefined , NaN Truthy: If a variable's value exists, it evaluates to true in a logical comparison let defaultName; if (username) { defaultName = username; } else { defaultName = 'Stranger'; } //Is equivalent to let defaultName = username || 'Stranger'; //Stranger is the default if usrname is falsy (DNE) A ternary operator can condense if...else statements If the condition before the ? is true, the 1st expression executes. If false, the 2nd expression executes let isNight = true; if (isNight){ console.log('Sleep') } else { console.log('Wakeup') } //Is equivalent to: isNight ? console.log('Sleep') : console.log('Wakeup'); Supports switch statements for easier syntax than numerous else if statements let item = 'Pie' switch (item) { case 'bread': //Do something break; case 'muffin': //Do something else break; default: //Last resort break; } Functions Hoisting applies to functions as well, allowing a function to be called before it is defined in the code Not good code practice though A function declaration binds a function to an identifier like getUser() using the function keyword ES6 added the ability to use default parameters function calcArea(width,height=10){ return width * height; } Helper functions- functions called within another function Function Expressions are another way to define a function The anonymous functions created by function expressions are stored in variables so they can be referenced const is used to declare the variable const calcArea = function(width,height){ return width * height; } ES6 introduced arrow function syntax as a shorter way to write functions (Documentation) Remove the need to type out the function keyword Include parameters inside the parentheses and add an arrow => pointing to the function body const calcArea = (width,height) => { return width * height; } Conscise Body Arrow Functions Functions taking 1 parameter don't need parentheses but 0 & 2+ parameters require parentheses Pushing the function to the single-line eliminates need for curly braces and return statement (implicitly returns the contents of the block) const sumNums = num => num + num; //Will return num + num Scope Defines where variablescan be accessed or referenced In block scope variables are declared inside a block (set of {} ) and are called local variables Local variables can only be accessed within the block In global scope variables are declared outside of a block and are called global variables Global variables can be accessed by any code in the program The global namespace is where global variables go and it allows them to be accessed anywhere in the program Scope Pollution occurs when too many global variables exist in the global namespace or when variables are reused across different scopes Best practice not to define variables in the global scope to avoid this proble Scope variables as tightly as possible using block scope Makes code more legible & understandable since blocks organize the code into discrete sections Easier to maintain the modular code Saves memory b/c the variables are automatically erased after the block is finished running Arrays Documentation Can store any combination of data types( const list = ['Hello',45,true] ) Traditional array access & updates( list[0] and list[1] = 56 ) Can change the contents of an array declared with const but cannot reassign a new array or different value to the variable .length property just like strings .push(item) adds items to the end of an array & .unshift(item) adds items to the beginning ofan array Can take multipe arguments to add multiple items at a time Changes/mutates the original array (Also classified as a destructive array method since it changes the initial array ) .pop() removes the last item of an array & .shift() removes the first item (Neither take any arguments) Changes/mutates the original array .indexOf(item) returns the index of an item in the array (not found = -1) .slice() copies an array ( let copy = og.slice(); ) .splice(pos,n) removes the item at pos n times Changes the original array and returns the removed items as another array Pass-by-Reference is when an array is passed into a function, if the array is mutated inside the function, that change will be maintained outside the function as well Works because the argument to the function is just a reference to where the variable is stored in memory, allowing the memory of the array to be changed Nested arrays can be accessed by chaining on more bracket notation with index values (e.g. arry[1][3] ) let nums = [1,5,7,3,9]; let num2 = new Array(1,3,6,'Hi',3,7); nums.push(10); nums.length num2.sort() //Strings come last nums.reverse() //Reverses order Loops for loop consists of an initialization, stopping condition, and iteration statement Do while loops run a piece of code then check the condition compared to while loops that check the condition and then run the code Do while loops run at least once whether or not the condition evaluates to true break keyword allows programs to break out of a loop within the loop's block for (let i = 0; i < 5, i++){} for (let i = items.length - 1; i >= 0; i--){} //Reverse through a list while (condition) {} //Avoid infinite loops! do {} while (condition) Higher-Order Functions Functions that accept other functions as arguments and/or return functions as output Callback Functions are functions that are passed as arguments and invoked Get called during the excution of the higher-order function To pass a callback function as ana argument, the name is typed w/o the parentheses so that the reference to the function is passed, not the value from invoking the function Anonymous functions can be passed as arguments as well (they are defined in the higher-order function's call) Adds another level of abstraction to a program to make it more modular & easier to read/debug JS functions are first class objects meaning that like other objects, JS functions can have properties and methods Functions are special b/c they can be invoked and treated like any other type of data Every JS function is actually a Function object ( Documentation ) Iterators These iterators take a callback function as an argument and execute the callback function for each element in the array .forEach() const fruits = ['mango', 'papaya', 'pineapple', 'apple']; fruits.forEach(elem=>console.log(`I want to eat a ${elem}`)); //I want to eat a mango...papaya...etc. .map() returns a new array unlike forEach which mutates the original array const nums = [1,2,3,4]; const bigNums = nums.map(number => number * 10); //[10,20,30,40] .filter() takes a boolean callback function (returns T/F) as an argument. Returns a new array const favoriteWords = ['nostalgia', 'hyperbole', 'fervent', 'esoteric', 'serene']; const longFavoriteWords = favoriteWords.filter(elem=> { return elem.length > 7; }); .findIndex() Returns the index of the first element that evaluates to true in the boolean callback function No element that satisfies the callback returns -1 ``` javascript const jumbledNums = [123, 25, 78, 5, 9]; const lessThanTen = jumbledNums.findIndex(num => { return num < 10; }); //3 - `.reduce()` returns a single value after iterating through the elements of an array (Consists of an accumulator and iterator) - The optional 2nd argument sets the initial value for accumulator ```javascript const nums = [1,2,3,4]; const summedNums = nums.reduce((accumulator,currentVal) => { console.log('The value of accumulator: ', accumulator); console.log('The value of currentValue: ', currentValue); return accumulator + currentVal; },100); //110","title":"Basics"},{"location":"web_dev/js/basics/#what-is-javascript","text":"Dynamic Programming Language (operations done at run-time) E.g. Possible to change variable type or add new properties/methods to an object while the program is running Dynamically-Typed Language (Interpreter assigns variables a type at runtime based on its current value) Can provide interactivity on websites when applied to an html document Interpreted language (Doesn't have to be compiled) Runs on the client's computer/browser Object Based Prototype based instead of class based like Java Scripting language (lightweight)","title":"What is JavaScript"},{"location":"web_dev/js/basics/#uses-for-javascript","text":"Put content in an HTML page on the fly Make webpages responsive Detect a user's browser and other info Create cookies Validate forms Create animations, slideshows, scrollers, etc Build apps w/ JS frameworks (ex: angularJS, reactJS, etc)","title":"Uses for JavaScript:"},{"location":"web_dev/js/basics/#primitive-data-types","text":"Number- integers and decimals String- use single or double quotes (single preferred) .length property Boolean- true or false Null- intentional absence of a value represnted by null Undefined- absence of a valuae represented by undefined and is different than null Symbol- unique identifiers and useful in more complex coding","title":"Primitive Data Types"},{"location":"web_dev/js/basics/#variables","text":"When declaring variables without assigning a value, their inital value is set to undefined Prior to ES6, var was the only keyword to declare variables ( More Info ) Variables declared using var are created before any code is executed in a process known as hoisting A variable's initial value is undefined and its actual value is intialized when the assignment statement is reached in execution This means a variable can be used before it is declared in the code since hoisting results in the equivalent of all variables being declared at the top In ES6, let and const were introduced let signals that the variable can be reassigned a different value const signals that the variable is a constant and cannot be reassigned Reassigning a const will throw a TypeError Variables can be transformed using mathematical asignment operators ( += , *= , /= ) and increment/decrement operators ( ++ , -- ) In ES6, we can insert (or interpolate) variables into strings using template literals Uses backticks instead of single/double quotes const myPet = 'armadillo'; console.log(`I own a pet ${myPet}`); // Output: I own a pet armadillo. typeof operator will return a string of the data type of the value to its right (e.g. typeof 'hello' returns 'string')","title":"Variables"},{"location":"web_dev/js/basics/#conditional-statements","text":"if (greeting) { console.log('Hello World!') } else if (goodbye){ console.log('Bye World!') } else { console.log('IDK') } Comparison Operators: < , > , <= , >= , === , !== Don't use == or != b/c types are not considered (Read More) Logical Operators: and && , or || , not: ! Values that are not explicitly true/false but evaluate to true/false are called truthy/falsy Falsy: 0 ,empty strings, null , undefined , NaN Truthy: If a variable's value exists, it evaluates to true in a logical comparison let defaultName; if (username) { defaultName = username; } else { defaultName = 'Stranger'; } //Is equivalent to let defaultName = username || 'Stranger'; //Stranger is the default if usrname is falsy (DNE) A ternary operator can condense if...else statements If the condition before the ? is true, the 1st expression executes. If false, the 2nd expression executes let isNight = true; if (isNight){ console.log('Sleep') } else { console.log('Wakeup') } //Is equivalent to: isNight ? console.log('Sleep') : console.log('Wakeup'); Supports switch statements for easier syntax than numerous else if statements let item = 'Pie' switch (item) { case 'bread': //Do something break; case 'muffin': //Do something else break; default: //Last resort break; }","title":"Conditional Statements"},{"location":"web_dev/js/basics/#functions","text":"Hoisting applies to functions as well, allowing a function to be called before it is defined in the code Not good code practice though A function declaration binds a function to an identifier like getUser() using the function keyword ES6 added the ability to use default parameters function calcArea(width,height=10){ return width * height; } Helper functions- functions called within another function Function Expressions are another way to define a function The anonymous functions created by function expressions are stored in variables so they can be referenced const is used to declare the variable const calcArea = function(width,height){ return width * height; } ES6 introduced arrow function syntax as a shorter way to write functions (Documentation) Remove the need to type out the function keyword Include parameters inside the parentheses and add an arrow => pointing to the function body const calcArea = (width,height) => { return width * height; } Conscise Body Arrow Functions Functions taking 1 parameter don't need parentheses but 0 & 2+ parameters require parentheses Pushing the function to the single-line eliminates need for curly braces and return statement (implicitly returns the contents of the block) const sumNums = num => num + num; //Will return num + num","title":"Functions"},{"location":"web_dev/js/basics/#scope","text":"Defines where variablescan be accessed or referenced In block scope variables are declared inside a block (set of {} ) and are called local variables Local variables can only be accessed within the block In global scope variables are declared outside of a block and are called global variables Global variables can be accessed by any code in the program The global namespace is where global variables go and it allows them to be accessed anywhere in the program Scope Pollution occurs when too many global variables exist in the global namespace or when variables are reused across different scopes Best practice not to define variables in the global scope to avoid this proble Scope variables as tightly as possible using block scope Makes code more legible & understandable since blocks organize the code into discrete sections Easier to maintain the modular code Saves memory b/c the variables are automatically erased after the block is finished running","title":"Scope"},{"location":"web_dev/js/basics/#arrays","text":"Documentation Can store any combination of data types( const list = ['Hello',45,true] ) Traditional array access & updates( list[0] and list[1] = 56 ) Can change the contents of an array declared with const but cannot reassign a new array or different value to the variable .length property just like strings .push(item) adds items to the end of an array & .unshift(item) adds items to the beginning ofan array Can take multipe arguments to add multiple items at a time Changes/mutates the original array (Also classified as a destructive array method since it changes the initial array ) .pop() removes the last item of an array & .shift() removes the first item (Neither take any arguments) Changes/mutates the original array .indexOf(item) returns the index of an item in the array (not found = -1) .slice() copies an array ( let copy = og.slice(); ) .splice(pos,n) removes the item at pos n times Changes the original array and returns the removed items as another array Pass-by-Reference is when an array is passed into a function, if the array is mutated inside the function, that change will be maintained outside the function as well Works because the argument to the function is just a reference to where the variable is stored in memory, allowing the memory of the array to be changed Nested arrays can be accessed by chaining on more bracket notation with index values (e.g. arry[1][3] ) let nums = [1,5,7,3,9]; let num2 = new Array(1,3,6,'Hi',3,7); nums.push(10); nums.length num2.sort() //Strings come last nums.reverse() //Reverses order","title":"Arrays"},{"location":"web_dev/js/basics/#loops","text":"for loop consists of an initialization, stopping condition, and iteration statement Do while loops run a piece of code then check the condition compared to while loops that check the condition and then run the code Do while loops run at least once whether or not the condition evaluates to true break keyword allows programs to break out of a loop within the loop's block for (let i = 0; i < 5, i++){} for (let i = items.length - 1; i >= 0; i--){} //Reverse through a list while (condition) {} //Avoid infinite loops! do {} while (condition)","title":"Loops"},{"location":"web_dev/js/basics/#higher-order-functions","text":"Functions that accept other functions as arguments and/or return functions as output Callback Functions are functions that are passed as arguments and invoked Get called during the excution of the higher-order function To pass a callback function as ana argument, the name is typed w/o the parentheses so that the reference to the function is passed, not the value from invoking the function Anonymous functions can be passed as arguments as well (they are defined in the higher-order function's call) Adds another level of abstraction to a program to make it more modular & easier to read/debug JS functions are first class objects meaning that like other objects, JS functions can have properties and methods Functions are special b/c they can be invoked and treated like any other type of data Every JS function is actually a Function object ( Documentation )","title":"Higher-Order Functions"},{"location":"web_dev/js/basics/#iterators","text":"These iterators take a callback function as an argument and execute the callback function for each element in the array .forEach() const fruits = ['mango', 'papaya', 'pineapple', 'apple']; fruits.forEach(elem=>console.log(`I want to eat a ${elem}`)); //I want to eat a mango...papaya...etc. .map() returns a new array unlike forEach which mutates the original array const nums = [1,2,3,4]; const bigNums = nums.map(number => number * 10); //[10,20,30,40] .filter() takes a boolean callback function (returns T/F) as an argument. Returns a new array const favoriteWords = ['nostalgia', 'hyperbole', 'fervent', 'esoteric', 'serene']; const longFavoriteWords = favoriteWords.filter(elem=> { return elem.length > 7; }); .findIndex() Returns the index of the first element that evaluates to true in the boolean callback function No element that satisfies the callback returns -1 ``` javascript const jumbledNums = [123, 25, 78, 5, 9]; const lessThanTen = jumbledNums.findIndex(num => { return num < 10; }); //3 - `.reduce()` returns a single value after iterating through the elements of an array (Consists of an accumulator and iterator) - The optional 2nd argument sets the initial value for accumulator ```javascript const nums = [1,2,3,4]; const summedNums = nums.reduce((accumulator,currentVal) => { console.log('The value of accumulator: ', accumulator); console.log('The value of currentValue: ', currentValue); return accumulator + currentVal; },100); //110","title":"Iterators"},{"location":"web_dev/js/browser_compatibility/","text":"Browser Compatibility Some ES6 features, like modules, are still not supported by most web browsers caniuse.com is the bset resource for finding browser compatiblity info on a feature-by-feature basis ES5 updated to ES6: Better readability and requires fewer characters Fixes ES5 bugs common from the syntax Syntax more similar to other OOP languages Ecma (Organization in charge of JS standards) made ES6 backwards compatible meaning it can be mapped to ES5 Backwards compatibility helps decrease browser compatibility issues Babel is a library that transpiles ES6 to ES5 JavaScript Transpilation- the process of converting one programming language to another babel-cli - Node package w/ command line tools for Babel babel-preset-env - Node package w/ ES6+ to ES5 syntax mapping information Transpilation (Detailed Notes) Setup the project using the specified file structure and npm bash project |_ src |___ main.js |_ package.json Run npm init to create a package.json file in the root directory that contains info about the current project: Metdata- Project Title, Description, Authors, etc List of Required Node Packages- npm downloads the packages in this list when other developers want to run your project Key-value pairs for command line scripts- can use npm to run these shorthand scripts to perform some process Install necessary Babel packages using node package manager (npm) bash npm install babel-cli -D npm install babel-preset-env -D install creates a folder called node_modules and copies the package files to it while also installing all the dependencies for the given package -D flag instructs npm to add each package to a property called devDependencies in package.json devDependencies allows other developers to run your project without installing each package separately Instead they can run npm install to instruct npm to look inside package.json and download all the packages listed in devDependencies New Directory Structure: ( ... indicates 100+ packages that npm installed) bash project |_ node_modules |___ .bin |___ ... |_ src |___ main.js |_ package.json Specify the initial JS version in .babelrc Run touch .babelrc in the root directory to create the file Define the preset for the source JS file ( [\"env\"] insrtucts Babel to transpile any code from ES6+) { \"presets\": [\"env\"] } Specify a script in package.json that initiates ES6+ to ES5 transpilation In the \"scripts\" object, add a property called \"build\" below \"test\" \"build\" 's value ( babel src -d lib ) is a command line method that trasnpiles ES6+ code to ES5 babel \u2014 The Babel command call responsible for transpiling code. src \u2014 Instructs Babel to transpile all JavaScript code inside the src directory. -d \u2014 Instructs Babel to write the transpiled code to a directory. lib \u2014 Babel writes the transpiled code to a directory called lib . json ... \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\", \"build\": \"babel src -d lib\" }, ... Type npm run build to build the transpile the code to ES5 where it is stored in a directory called lib as a file with the same name as the original file (./lib/main.js) The command runs the build script in package.json The one command transpiles all code in src - good for larger projects with numerous JS files Transpilation Process (Summary): Initialize your project using npm init and create a directory called src Install babel dependencies by running npm install babel-cli -D npm install babel-preset-env -D Create a .babelrc file inside your project and add the following code inside it: { \"presets\": [\"env\"] } Add the following script to your scripts object in package.json: json \"build\": \"babel src -d lib\" Run npm run build whenever you want to transpile your code from your src to lib directories","title":"Browser Compatibility"},{"location":"web_dev/js/browser_compatibility/#browser-compatibility","text":"Some ES6 features, like modules, are still not supported by most web browsers caniuse.com is the bset resource for finding browser compatiblity info on a feature-by-feature basis ES5 updated to ES6: Better readability and requires fewer characters Fixes ES5 bugs common from the syntax Syntax more similar to other OOP languages Ecma (Organization in charge of JS standards) made ES6 backwards compatible meaning it can be mapped to ES5 Backwards compatibility helps decrease browser compatibility issues Babel is a library that transpiles ES6 to ES5 JavaScript Transpilation- the process of converting one programming language to another babel-cli - Node package w/ command line tools for Babel babel-preset-env - Node package w/ ES6+ to ES5 syntax mapping information","title":"Browser Compatibility"},{"location":"web_dev/js/browser_compatibility/#transpilation-detailed-notes","text":"Setup the project using the specified file structure and npm bash project |_ src |___ main.js |_ package.json Run npm init to create a package.json file in the root directory that contains info about the current project: Metdata- Project Title, Description, Authors, etc List of Required Node Packages- npm downloads the packages in this list when other developers want to run your project Key-value pairs for command line scripts- can use npm to run these shorthand scripts to perform some process Install necessary Babel packages using node package manager (npm) bash npm install babel-cli -D npm install babel-preset-env -D install creates a folder called node_modules and copies the package files to it while also installing all the dependencies for the given package -D flag instructs npm to add each package to a property called devDependencies in package.json devDependencies allows other developers to run your project without installing each package separately Instead they can run npm install to instruct npm to look inside package.json and download all the packages listed in devDependencies New Directory Structure: ( ... indicates 100+ packages that npm installed) bash project |_ node_modules |___ .bin |___ ... |_ src |___ main.js |_ package.json Specify the initial JS version in .babelrc Run touch .babelrc in the root directory to create the file Define the preset for the source JS file ( [\"env\"] insrtucts Babel to transpile any code from ES6+) { \"presets\": [\"env\"] } Specify a script in package.json that initiates ES6+ to ES5 transpilation In the \"scripts\" object, add a property called \"build\" below \"test\" \"build\" 's value ( babel src -d lib ) is a command line method that trasnpiles ES6+ code to ES5 babel \u2014 The Babel command call responsible for transpiling code. src \u2014 Instructs Babel to transpile all JavaScript code inside the src directory. -d \u2014 Instructs Babel to write the transpiled code to a directory. lib \u2014 Babel writes the transpiled code to a directory called lib . json ... \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\", \"build\": \"babel src -d lib\" }, ... Type npm run build to build the transpile the code to ES5 where it is stored in a directory called lib as a file with the same name as the original file (./lib/main.js) The command runs the build script in package.json The one command transpiles all code in src - good for larger projects with numerous JS files","title":"Transpilation (Detailed Notes)"},{"location":"web_dev/js/browser_compatibility/#transpilation-process-summary","text":"Initialize your project using npm init and create a directory called src Install babel dependencies by running npm install babel-cli -D npm install babel-preset-env -D Create a .babelrc file inside your project and add the following code inside it: { \"presets\": [\"env\"] } Add the following script to your scripts object in package.json: json \"build\": \"babel src -d lib\" Run npm run build whenever you want to transpile your code from your src to lib directories","title":"Transpilation Process (Summary):"},{"location":"web_dev/js/classes/","text":"Classes Constructor JavaScript calls the constructor() method every time it creates a new instance of a class. class Dog { constructor(name) { this.name = name; this.behavior = 0; } } Instances An instance is an object that contains the property names and methods of a class, but with unique property values. const halley = new Dog('Halley'); console.log(halley.name); // Output: 'Halley' Methods Class method and getter syntax is the same as it is for objects except you can not include commas between methods. class Dog { constructor(name) { this._name = name; } get name() { return this._name; } incrementBehavior() { this._behavior++; } } Static Methods aren't available to instances and can only be called by the class Calling static methods from an instance throws a TypeError class Animal { constructor(name) { this._name = name; this._behavior = 0; } static generateName() { const names = ['Angel', 'Spike', 'Buffy', 'Willow', 'Tara']; const randomNumber = Math.floor(Math.random()*5); return names[randomNumber]; } } console.log(Animal.generateName()); // returns a name Inheritance Create a parent class (also known as a superclass) with properties and methods that multiple child classes (also known as subclasses) share Child classes inherit the properties and methods from their parent class Benefits (time saved, readability, efficiency) grow as the number and size of subclasses increase Adheres to DRY best practice JS uses extends keyword to extend the properties/methods of one clas to a subclass super() Calls the constructor of the parent class (with the appropriate parameters if necessary) super() must always be called before this can be used to define new properties (ReferenceError will be thrown otherwise) Best Practice: Always call super() on the first line of subclass constructors class Animal { constructor(name) { this._name = name; this._behavior = 0; } get name() { return this._name; } get behavior() { return this._behavior; } } class Cat extends Animal { constructor(name, usesLitter) { super(name); this._usesLitter = usesLitter; } }","title":"Classes"},{"location":"web_dev/js/classes/#classes","text":"","title":"Classes"},{"location":"web_dev/js/classes/#constructor","text":"JavaScript calls the constructor() method every time it creates a new instance of a class. class Dog { constructor(name) { this.name = name; this.behavior = 0; } }","title":"Constructor"},{"location":"web_dev/js/classes/#instances","text":"An instance is an object that contains the property names and methods of a class, but with unique property values. const halley = new Dog('Halley'); console.log(halley.name); // Output: 'Halley'","title":"Instances"},{"location":"web_dev/js/classes/#methods","text":"Class method and getter syntax is the same as it is for objects except you can not include commas between methods. class Dog { constructor(name) { this._name = name; } get name() { return this._name; } incrementBehavior() { this._behavior++; } } Static Methods aren't available to instances and can only be called by the class Calling static methods from an instance throws a TypeError class Animal { constructor(name) { this._name = name; this._behavior = 0; } static generateName() { const names = ['Angel', 'Spike', 'Buffy', 'Willow', 'Tara']; const randomNumber = Math.floor(Math.random()*5); return names[randomNumber]; } } console.log(Animal.generateName()); // returns a name","title":"Methods"},{"location":"web_dev/js/classes/#inheritance","text":"Create a parent class (also known as a superclass) with properties and methods that multiple child classes (also known as subclasses) share Child classes inherit the properties and methods from their parent class Benefits (time saved, readability, efficiency) grow as the number and size of subclasses increase Adheres to DRY best practice JS uses extends keyword to extend the properties/methods of one clas to a subclass super() Calls the constructor of the parent class (with the appropriate parameters if necessary) super() must always be called before this can be used to define new properties (ReferenceError will be thrown otherwise) Best Practice: Always call super() on the first line of subclass constructors class Animal { constructor(name) { this._name = name; this._behavior = 0; } get name() { return this._name; } get behavior() { return this._behavior; } } class Cat extends Animal { constructor(name, usesLitter) { super(name); this._usesLitter = usesLitter; } }","title":"Inheritance"},{"location":"web_dev/js/jQuery/","text":"jQuery An easy to learn JS library that simplifies JS web programming Wraps common, lengthy tasks into methods that can be called in a single line Simplifies complicated JS things such as AJAX calls & DOM manipulation Contains Following Features: HTML/DOM manipulation CSS manipulation HTML event methods Effects and animations AJAX Utilities Many other plugins for other tasks Add to Webpages: Download production or development version from jQuery.com into project folder and add it to your project file <head> <script src=\"jquery-3.5.1.min.js\"></script> </head> OR include it from a CDN (Content Delivery Network) such as google: Loaded from users cache when they visit your site and it uses google's CDN (faster loading) <head> <script src=\"https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js\"></script> </head> Syntax Tailor-made for selecting HTML elements and performing some action on the element(s). Basic syntax is: $(selector).action() A $ sign to define/access jQuery A (selector) to \"query (or find)\" HTML elements A jQuery action() to be performed on the element(s) Document Ready Event All jQuery methods are inside a document ready event to prevent any jQuery code from running before the document is finished loading (is ready) Actions on the DOM can fail if document is fully loaded before code is executed $(document).ready(function(){ // jQuery methods go here.. }); //or the shorter version: $(function(){ // jQuery methods go here... }); Selectors Allow you to select and manipulate HTML elements Used to \"find\" (or select) HTML elements based on their name, id, classes, types, attributes, values of attributes and much more. Based on the existing CSS Selectors andit has some own custom selectors Element: $(\"p\") Id: $(#ex_id) Class: $(\".ex_class\")","title":"jQuery"},{"location":"web_dev/js/jQuery/#jquery","text":"An easy to learn JS library that simplifies JS web programming Wraps common, lengthy tasks into methods that can be called in a single line Simplifies complicated JS things such as AJAX calls & DOM manipulation Contains Following Features: HTML/DOM manipulation CSS manipulation HTML event methods Effects and animations AJAX Utilities Many other plugins for other tasks","title":"jQuery"},{"location":"web_dev/js/jQuery/#add-to-webpages","text":"Download production or development version from jQuery.com into project folder and add it to your project file <head> <script src=\"jquery-3.5.1.min.js\"></script> </head> OR include it from a CDN (Content Delivery Network) such as google: Loaded from users cache when they visit your site and it uses google's CDN (faster loading) <head> <script src=\"https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js\"></script> </head>","title":"Add to Webpages:"},{"location":"web_dev/js/jQuery/#syntax","text":"Tailor-made for selecting HTML elements and performing some action on the element(s). Basic syntax is: $(selector).action() A $ sign to define/access jQuery A (selector) to \"query (or find)\" HTML elements A jQuery action() to be performed on the element(s)","title":"Syntax"},{"location":"web_dev/js/jQuery/#document-ready-event","text":"All jQuery methods are inside a document ready event to prevent any jQuery code from running before the document is finished loading (is ready) Actions on the DOM can fail if document is fully loaded before code is executed $(document).ready(function(){ // jQuery methods go here.. }); //or the shorter version: $(function(){ // jQuery methods go here... });","title":"Document Ready Event"},{"location":"web_dev/js/jQuery/#selectors","text":"Allow you to select and manipulate HTML elements Used to \"find\" (or select) HTML elements based on their name, id, classes, types, attributes, values of attributes and much more. Based on the existing CSS Selectors andit has some own custom selectors Element: $(\"p\") Id: $(#ex_id) Class: $(\".ex_class\")","title":"Selectors"},{"location":"web_dev/js/modules/","text":"Modules Overview Reusable pieces of code that can be exported from one program and imported for use in another program Benefits of Using Modules: Find, fix, and debug code more easily Reuse and recycle logic defined in different parts of our application Keep information private and protected from other modules Prevent pollution of the global namespace and potential naming collisions, by cautiously selecting variables and behavior we load into a program Two Ways of Implementing Modules: Node.js's module.exports and require() syntax ES6 import / export syntax Node.js Syntax module.exports Every JavaScript file run in Node has a local module object with an exports property used to define what should be exported from the file The pattern we use to export modules: Create an object to represent the module. Add properties or methods to the module object. Export the module with module.exports . let Menu = {}; Menu.specialty = \"Roasted Beet Burger with Mint Sauce\"; module.exports = Menu; Can also wrap any collection of data/functions in an object and export the object (Equivalent to above block) module.exports = { specialty: \"Roasted Beet Burger with Mint Sauce\", getSpecialty: function() { return this.specialty; } }; require() Used in Node to import the exported module into another file so its defined behavior can be used Takes a file path argument pointing to the original module file The .js extension in the file path is optional and will be assumed if not included The pattern to import a module: Import the module with require() and assign it to a local variable. Use the module and its properties within a program. const Menu = require('./menu.js'); function placeOrder() { console.log('My order is: ' + Menu.specialty); } placeOrder(); ES6 Syntax export default Works similarly to the module.exports syntax, allowing us to export 1 module per file Not supported in Node.js so this syntax is used for front-end development let Menu = {}; export default Menu; import The name following import specifies the name of the variable to store the default export in When specifying the path name after from , .js is left off because it specifically refers to the name of the file w/o the extension of the file when dealing with local files import Menu from './menu'; Named Exports Allow us to export data through the use of variables let specialty = ''; function isVegetarian() {}; export { specialty, isVegetarian }; Named exports can have their name changed when exported using as let specialty = ''; let isVegetarian = function() {}; export { specialty as chefsSpecial, isVegetarian as isVeg }; Variables can be exported as soon as they are declared by placing export in front of variable declarations export let specialty = ''; export function isVegetarian() {}; Named exports and default exports can be used together Best not to use both methods but can occasionally be useful Ex: If you suspect developers may only be interested in importing a specific function and won\u2019t need to import the entire default export. let specialty = ''; function isVegetarian() {}; function isGlutenFree() {}; export { specialty as chefsSpecial, isVegetarian as isVeg }; export default isGlutenFree; Named Imports To import objects stored in a variable, we use the import keyword and include the variables in a set of {} Don't have to import all the variables exported in the other module import { specialty, isVegetarian } from './menu'; console.log(specialty); Named exports can have their name changed when exported/imported using as import {speciality as chefsSpecial, isVegetarian as isVeg} from './menu'; //or import * as Carte from './menu'; Carte.speciality; Carte.isVegetarian(); Named imports and normal imports can be used together import { specialty, isVegetarian } from './menu'; import GlutenFree from './menu';","title":"Modules"},{"location":"web_dev/js/modules/#modules-overview","text":"Reusable pieces of code that can be exported from one program and imported for use in another program Benefits of Using Modules: Find, fix, and debug code more easily Reuse and recycle logic defined in different parts of our application Keep information private and protected from other modules Prevent pollution of the global namespace and potential naming collisions, by cautiously selecting variables and behavior we load into a program Two Ways of Implementing Modules: Node.js's module.exports and require() syntax ES6 import / export syntax","title":"Modules Overview"},{"location":"web_dev/js/modules/#nodejs-syntax","text":"","title":"Node.js Syntax"},{"location":"web_dev/js/modules/#moduleexports","text":"Every JavaScript file run in Node has a local module object with an exports property used to define what should be exported from the file The pattern we use to export modules: Create an object to represent the module. Add properties or methods to the module object. Export the module with module.exports . let Menu = {}; Menu.specialty = \"Roasted Beet Burger with Mint Sauce\"; module.exports = Menu; Can also wrap any collection of data/functions in an object and export the object (Equivalent to above block) module.exports = { specialty: \"Roasted Beet Burger with Mint Sauce\", getSpecialty: function() { return this.specialty; } };","title":"module.exports"},{"location":"web_dev/js/modules/#require","text":"Used in Node to import the exported module into another file so its defined behavior can be used Takes a file path argument pointing to the original module file The .js extension in the file path is optional and will be assumed if not included The pattern to import a module: Import the module with require() and assign it to a local variable. Use the module and its properties within a program. const Menu = require('./menu.js'); function placeOrder() { console.log('My order is: ' + Menu.specialty); } placeOrder();","title":"require()"},{"location":"web_dev/js/modules/#es6-syntax","text":"","title":"ES6 Syntax"},{"location":"web_dev/js/modules/#export-default","text":"Works similarly to the module.exports syntax, allowing us to export 1 module per file Not supported in Node.js so this syntax is used for front-end development let Menu = {}; export default Menu;","title":"export default"},{"location":"web_dev/js/modules/#import","text":"The name following import specifies the name of the variable to store the default export in When specifying the path name after from , .js is left off because it specifically refers to the name of the file w/o the extension of the file when dealing with local files import Menu from './menu';","title":"import"},{"location":"web_dev/js/modules/#named-exports","text":"Allow us to export data through the use of variables let specialty = ''; function isVegetarian() {}; export { specialty, isVegetarian }; Named exports can have their name changed when exported using as let specialty = ''; let isVegetarian = function() {}; export { specialty as chefsSpecial, isVegetarian as isVeg }; Variables can be exported as soon as they are declared by placing export in front of variable declarations export let specialty = ''; export function isVegetarian() {}; Named exports and default exports can be used together Best not to use both methods but can occasionally be useful Ex: If you suspect developers may only be interested in importing a specific function and won\u2019t need to import the entire default export. let specialty = ''; function isVegetarian() {}; function isGlutenFree() {}; export { specialty as chefsSpecial, isVegetarian as isVeg }; export default isGlutenFree;","title":"Named Exports"},{"location":"web_dev/js/modules/#named-imports","text":"To import objects stored in a variable, we use the import keyword and include the variables in a set of {} Don't have to import all the variables exported in the other module import { specialty, isVegetarian } from './menu'; console.log(specialty); Named exports can have their name changed when exported/imported using as import {speciality as chefsSpecial, isVegetarian as isVeg} from './menu'; //or import * as Carte from './menu'; Carte.speciality; Carte.isVegetarian(); Named imports and normal imports can be used together import { specialty, isVegetarian } from './menu'; import GlutenFree from './menu';","title":"Named Imports"},{"location":"web_dev/js/objects/","text":"Objects Are passed by reference meaning the variable assigned to an object points to the space in memory holding the object when passed into a function as an argument Functions that change object properties actually mutate the object permanently even when assigned to a const variable Can be iterated through using the for...in syntax that executes a given block of code for each property in an object ( Documentation ) for (let member in spaceship.crew) {} Object Literal Data is organized into key-value pairs where a key points to a location in memory that holds a value Keys are strings but values can be any data type When the keys don't have special characters, JS allows the quotation marks to be omitted Key serves as a method's name and the value is an anonymous function expression ES6 syntax allows omission of the colon and function keyword let person = { firstName: 'John', secondName: 'Doe', age: 30, children: ['Bob','Joe'] //Embedded Object address : { street: '555 Heaven Ave', city: 'Boston', state: 'MA' }, fullName: function(){ return this.firstname + ' ' + this.lastName; } //Same as fullName2 () { console.log(this.firstname) } } There are 2 notations used for accessing object properties: dot and bracket Braket notation must be used when accessing keys that have numbers, spaces, or special characters Also used for property assignment/creation Can't reassign an object declared with const delete operator is used to delete properties //Dot Notation person.age; person.children[0]; person.address.street; //Bracket Notation property = 'age'; person[property]; person['children'][0]; person['address']['street']; Object Constructor let apple = new Object(); apple.color = 'red'; apple.shape = 'round'; apple.describe = function(){ return \"Color: \" +this.color+' Shape: '+this.shape; } Constructor Pattern: function Fruit(name,color,shape){ this.name = name; this.color = color; this.shape = shape; this.describe = function(){ return \"This is \"+this.color; } } let apple = new Fruit('apple','red','round'); this Keyword Similar functionality to self keyword used for clases in python Used to reference other properties/methods of an object from within the object this references the calling object which provides access to the calling object's properties A ReferenceError is thrown if this is not used const goat = { dietType: 'herbivore', diet() { console.log(this.dietType); } }; goat.diet(); //Output: herbivore arrow functions bind/tie this to the function itself, not the calling object In the below example, the value of this is the global object (an object that exists in the global scope), which doesn't have a dietType property, therefore returnining undefined Avoid using arrow functions when using this in a method const goat = { dietType: 'herbivore', diet: () => { console.log(this.dietType); } }; goat.diet(); // Prints undefined Privacy Only certain properties should be mutable/able to change in value JS does not have privacy built-in for objects Naming conventions indicate how a developer should interact with a property Underscores _ before the name of a property: do not alter Getters are used to return internal properties of an object Syntax: get keyword followed by a function(){} Can perform an action on the data when getting a property Can return different values using conditionals Easier readability const person = { _firstName: 'John', _lastName: 'Doe', get fullName() { if (this._firstName && this._lastName){ return `${this._firstName} ${this._lastName}`; } else { return 'Missing a first name or a last name.'; } } } //Using a Getter person.fullName; // 'John Doe' Setters are used to reassign values of an object's properties const person = { _age: 37, set age(newAge){ if (typeof newAge === 'number'){ this._age = newAge; } else { console.log('You must assign a number to age'); } } }; //Using a Setter person.age = 40 console.log(person._age) //40 Factory Functions Returns an object that can be reused to make multiple object instances Simply returns an object Can have parameters allowing customization of the returned object const monsterFactory = (name, age, energySource, catchPhrase) => { return { name: name, age: age, energySource: energySource, scare() { console.log(catchPhrase); } } }; const ghost = monsterFactory('Ghouly', 251, 'ectoplasm', 'BOO!'); ghost.scare(); // 'BOO!' Destructuring An ES6 shortcut for assigning an object's properties to variables Property Value Shorthand can be used in creating factory functions where the property's name is the same as the variable it is being assigned to const monsterFactory = (name, age) => { return { name, age } }; Destructured Assignment is similar to unpacking in python where an object's properties can be concisely assigned to new variables const vampire = { name: 'Dracula', residence: 'Transylvania', preferences: { day: 'stay inside', night: 'satisfy appetite' } }; const {residence} = vampire; //Transylvania const {day} = vampire.preferences //Stay inside Built-In Object Methods Object Instance Methods: (Documentation) .hasOwnProperty() , .valueOf() Object Class Methods: Object.keys(name_of_obj) : Returns an array of the keys/property names of an object Object.entries(name_of_obj) : Returns an array containing arrays that have the key & value for each property Object.assign(target_obj,src_object) : Copies properties from the source object (s) to the target object and returns the target object","title":"Objects"},{"location":"web_dev/js/objects/#objects","text":"Are passed by reference meaning the variable assigned to an object points to the space in memory holding the object when passed into a function as an argument Functions that change object properties actually mutate the object permanently even when assigned to a const variable Can be iterated through using the for...in syntax that executes a given block of code for each property in an object ( Documentation ) for (let member in spaceship.crew) {}","title":"Objects"},{"location":"web_dev/js/objects/#object-literal","text":"Data is organized into key-value pairs where a key points to a location in memory that holds a value Keys are strings but values can be any data type When the keys don't have special characters, JS allows the quotation marks to be omitted Key serves as a method's name and the value is an anonymous function expression ES6 syntax allows omission of the colon and function keyword let person = { firstName: 'John', secondName: 'Doe', age: 30, children: ['Bob','Joe'] //Embedded Object address : { street: '555 Heaven Ave', city: 'Boston', state: 'MA' }, fullName: function(){ return this.firstname + ' ' + this.lastName; } //Same as fullName2 () { console.log(this.firstname) } } There are 2 notations used for accessing object properties: dot and bracket Braket notation must be used when accessing keys that have numbers, spaces, or special characters Also used for property assignment/creation Can't reassign an object declared with const delete operator is used to delete properties //Dot Notation person.age; person.children[0]; person.address.street; //Bracket Notation property = 'age'; person[property]; person['children'][0]; person['address']['street'];","title":"Object Literal"},{"location":"web_dev/js/objects/#object-constructor","text":"let apple = new Object(); apple.color = 'red'; apple.shape = 'round'; apple.describe = function(){ return \"Color: \" +this.color+' Shape: '+this.shape; }","title":"Object Constructor"},{"location":"web_dev/js/objects/#constructor-pattern","text":"function Fruit(name,color,shape){ this.name = name; this.color = color; this.shape = shape; this.describe = function(){ return \"This is \"+this.color; } } let apple = new Fruit('apple','red','round');","title":"Constructor Pattern:"},{"location":"web_dev/js/objects/#this-keyword","text":"Similar functionality to self keyword used for clases in python Used to reference other properties/methods of an object from within the object this references the calling object which provides access to the calling object's properties A ReferenceError is thrown if this is not used const goat = { dietType: 'herbivore', diet() { console.log(this.dietType); } }; goat.diet(); //Output: herbivore arrow functions bind/tie this to the function itself, not the calling object In the below example, the value of this is the global object (an object that exists in the global scope), which doesn't have a dietType property, therefore returnining undefined Avoid using arrow functions when using this in a method const goat = { dietType: 'herbivore', diet: () => { console.log(this.dietType); } }; goat.diet(); // Prints undefined","title":"this Keyword"},{"location":"web_dev/js/objects/#privacy","text":"Only certain properties should be mutable/able to change in value JS does not have privacy built-in for objects Naming conventions indicate how a developer should interact with a property Underscores _ before the name of a property: do not alter Getters are used to return internal properties of an object Syntax: get keyword followed by a function(){} Can perform an action on the data when getting a property Can return different values using conditionals Easier readability const person = { _firstName: 'John', _lastName: 'Doe', get fullName() { if (this._firstName && this._lastName){ return `${this._firstName} ${this._lastName}`; } else { return 'Missing a first name or a last name.'; } } } //Using a Getter person.fullName; // 'John Doe' Setters are used to reassign values of an object's properties const person = { _age: 37, set age(newAge){ if (typeof newAge === 'number'){ this._age = newAge; } else { console.log('You must assign a number to age'); } } }; //Using a Setter person.age = 40 console.log(person._age) //40","title":"Privacy"},{"location":"web_dev/js/objects/#factory-functions","text":"Returns an object that can be reused to make multiple object instances Simply returns an object Can have parameters allowing customization of the returned object const monsterFactory = (name, age, energySource, catchPhrase) => { return { name: name, age: age, energySource: energySource, scare() { console.log(catchPhrase); } } }; const ghost = monsterFactory('Ghouly', 251, 'ectoplasm', 'BOO!'); ghost.scare(); // 'BOO!'","title":"Factory Functions"},{"location":"web_dev/js/objects/#destructuring","text":"An ES6 shortcut for assigning an object's properties to variables Property Value Shorthand can be used in creating factory functions where the property's name is the same as the variable it is being assigned to const monsterFactory = (name, age) => { return { name, age } }; Destructured Assignment is similar to unpacking in python where an object's properties can be concisely assigned to new variables const vampire = { name: 'Dracula', residence: 'Transylvania', preferences: { day: 'stay inside', night: 'satisfy appetite' } }; const {residence} = vampire; //Transylvania const {day} = vampire.preferences //Stay inside","title":"Destructuring"},{"location":"web_dev/js/objects/#built-in-object-methods","text":"Object Instance Methods: (Documentation) .hasOwnProperty() , .valueOf() Object Class Methods: Object.keys(name_of_obj) : Returns an array of the keys/property names of an object Object.entries(name_of_obj) : Returns an array containing arrays that have the key & value for each property Object.assign(target_obj,src_object) : Copies properties from the source object (s) to the target object and returns the target object","title":"Built-In Object Methods"},{"location":"web_dev/js/promises/","text":"Ayscnhronous Programming An asynchronous operation is one that allows the computer to \u201cmove on\u201d to other tasks while waiting for the asynchronous operation to complete Asynchronous programming means that time-consuming operations don\u2019t have to bring everything else in our programs to a halt JS handles asynchronicity using the Promise object, introduced with ES6 What is a Promise? Promises are objects that represent the eventual outcome of an asynchronous operation A Promise object can be in one of three states: Pending : The initial state\u2014 the operation has not completed yet. Fulfilled : The operation has completed successfully and the promise now has a resolved value . For example, a request\u2019s promise might resolve with a JSON object as its value. Rejected : The operation has failed and the promise has a reason for the failure. This reason is usually an Error of some kind. A promise is settled if it is no longer pending (it is either fufilled or rejected) All promises eventually settle Enables us to write logic for what to do if the promise fulfills or is rejected Promises are returned from a asyncrhonous operations Constructing a Promise Object Promise constructor takes a function called the executor function as an argument Executor Function runs automatically when constructor is called, generally starts an asynchronous operation, and dictates how the promsie should be settled Has 2 function parameters: resolve() and reject() (These functions aren't defined by the progammer but are rather passed by JS into the executor function when the Promise constructor runs) resolve has one argument and will change the promise's status from pending to fulfilled if invoked and will set the resolved value to the argument passed in reject takes a reason or error as an argument and will change the promise's status from pending to rejected if invoked and will set the rejection's reason to the argument passed in Promises settle based on the results of an asynch operation (e.g. Database request is fulfilled with data from the query or is rejected with an error thrown) const executorFunction = (resolve,reject) => { if (condition){ resolve('Say Something') } else { reject('Say a different thing') } } const myPromise = new Promise(executorFunction) setTimeout() in Node: Takes a callback function and delay in milliseconds as arguments The callback function will execute in at least the passed in delay (Could be longer) This happens b/c after the delay, the line of code is added to be run but any synchronous code from the program will run before it, possibly delaying the callback functions execution","title":"Promises"},{"location":"web_dev/js/promises/#ayscnhronous-programming","text":"An asynchronous operation is one that allows the computer to \u201cmove on\u201d to other tasks while waiting for the asynchronous operation to complete Asynchronous programming means that time-consuming operations don\u2019t have to bring everything else in our programs to a halt JS handles asynchronicity using the Promise object, introduced with ES6","title":"Ayscnhronous Programming"},{"location":"web_dev/js/promises/#what-is-a-promise","text":"Promises are objects that represent the eventual outcome of an asynchronous operation A Promise object can be in one of three states: Pending : The initial state\u2014 the operation has not completed yet. Fulfilled : The operation has completed successfully and the promise now has a resolved value . For example, a request\u2019s promise might resolve with a JSON object as its value. Rejected : The operation has failed and the promise has a reason for the failure. This reason is usually an Error of some kind. A promise is settled if it is no longer pending (it is either fufilled or rejected) All promises eventually settle Enables us to write logic for what to do if the promise fulfills or is rejected Promises are returned from a asyncrhonous operations","title":"What is a Promise?"},{"location":"web_dev/js/promises/#constructing-a-promise-object","text":"Promise constructor takes a function called the executor function as an argument Executor Function runs automatically when constructor is called, generally starts an asynchronous operation, and dictates how the promsie should be settled Has 2 function parameters: resolve() and reject() (These functions aren't defined by the progammer but are rather passed by JS into the executor function when the Promise constructor runs) resolve has one argument and will change the promise's status from pending to fulfilled if invoked and will set the resolved value to the argument passed in reject takes a reason or error as an argument and will change the promise's status from pending to rejected if invoked and will set the rejection's reason to the argument passed in Promises settle based on the results of an asynch operation (e.g. Database request is fulfilled with data from the query or is rejected with an error thrown) const executorFunction = (resolve,reject) => { if (condition){ resolve('Say Something') } else { reject('Say a different thing') } } const myPromise = new Promise(executorFunction)","title":"Constructing a Promise Object"},{"location":"web_dev/js/promises/#settimeout-in-node","text":"Takes a callback function and delay in milliseconds as arguments The callback function will execute in at least the passed in delay (Could be longer) This happens b/c after the delay, the line of code is added to be run but any synchronous code from the program will run before it, possibly delaying the callback functions execution","title":"setTimeout() in Node:"},{"location":"web_dev/js/using_node_pkgs/","text":"Using Node Packages in a Project Initialize the project with npm init Install the desired packages with npm i package -D flag (Shorthand for --save-dev ) is used to save packages for necessary for development purposes (e.g. unit tests, minification, etc. ) Saves the package to \"devDependencies\" in package.json -S flag (Shorthand for --save) is used to save packages required for the application to run Saves them to \"dependencies\" in package.json Automatically saves new packages in npm 5+ Edit the \"scripts\" object in package.json to include necessary commands Run the scripts using npm run script_name Scripts: Sass (CSS Pre-Compiler): node-sass package should be saved to devDependencies \"sass\": \"node-sass -w scss/ -o dist/css/ --recursive\" Command watches (-w) the scss folder and outputs (-o) the compiled css to the css folder in the dist directory --recursive prevets issues with partials and auto-reloading Jest (JS Testing Framework): jest package should be saved to devDependencies \"test\": \"jest\" Babel (ES6+ to ES5 Transpilation): babel-cli and babel-preset-env packes should be saved to devDependencies \"build\": \"babel src -d lib\"","title":"Node Pkgs"},{"location":"web_dev/js/using_node_pkgs/#using-node-packages-in-a-project","text":"Initialize the project with npm init Install the desired packages with npm i package -D flag (Shorthand for --save-dev ) is used to save packages for necessary for development purposes (e.g. unit tests, minification, etc. ) Saves the package to \"devDependencies\" in package.json -S flag (Shorthand for --save) is used to save packages required for the application to run Saves them to \"dependencies\" in package.json Automatically saves new packages in npm 5+ Edit the \"scripts\" object in package.json to include necessary commands Run the scripts using npm run script_name","title":"Using Node Packages in a Project"},{"location":"web_dev/js/using_node_pkgs/#scripts","text":"","title":"Scripts:"},{"location":"web_dev/js/using_node_pkgs/#sass-css-pre-compiler","text":"node-sass package should be saved to devDependencies \"sass\": \"node-sass -w scss/ -o dist/css/ --recursive\" Command watches (-w) the scss folder and outputs (-o) the compiled css to the css folder in the dist directory --recursive prevets issues with partials and auto-reloading","title":"Sass (CSS Pre-Compiler):"},{"location":"web_dev/js/using_node_pkgs/#jest-js-testing-framework","text":"jest package should be saved to devDependencies \"test\": \"jest\"","title":"Jest (JS Testing Framework):"},{"location":"web_dev/js/using_node_pkgs/#babel-es6-to-es5-transpilation","text":"babel-cli and babel-preset-env packes should be saved to devDependencies \"build\": \"babel src -d lib\"","title":"Babel (ES6+ to ES5 Transpilation):"}]}