# Templates
- Permit the definition of a template class or template function that can be used with multiple data types
    - Requires only a single definition
    - Permits reuse
    - Compiler will create specific versions when functions are used with specific types
- Save time and avoid code replication
    - One class template that is instantiated for N specific classes with X associated member functions 
    - Instead of writing N * X member functions, you only write X
- Can result in code bloat (source code looks small but object code/binaries are large)
- Need to be recompiled for each translation unit (can dramatically increase compile time)
- Need to do a commonality and variability analysis 
    - Look for replication to idenfity when a template could instead be instantiated multiple times

## Function Templates
- Define a specific behavior that can be applied to any data type
    - Method overloading can be used to provide functionality for each data type
- Parameters and return type may be template types
``` c++
template <typename T>
void functionName(T paramName, ...){
    ...
}
```
- When program runs and a call to the function template is encountered:
    - 1) compiler substitutes the appropriate type(s) for the template params
    - 2) compiler compiles this version of the function
    - Multiple copies of function templates are created (one for each data type used)
- *Function templates*: specify a range of related functinos with a single code segment
    - Written by programmer
- *Template functions*: the individually compiled versions of the function tempalte 
    - Generated by compiler

## Class Templates
- Allow the program to contain a generic class definition that can be instantiated into a type specific object
- cpp files for template classes cannot be compiled on their own
    - Need to have types inserted to be compiled (must create an object to compile a template class)
- `.h` file for the template class will `#include '<name>.cpp'`
    - So the template's cpp file should be left out of the CMake list
    - Seperating interface from the implementation is good practice
- Common way is to implement everything in the `.h` for template classes (will see this in libraries often)
- Can pass a literal as a template parameter such as the int parameter below:

``` c++
// ClassName.h file
template<typename T, typename T2, int x>
class ClassName {
    public:
    ...
    private:
    ...
}

// ClassName.cpp file
template<typename T, typename T2, >
ClassName<T, T2, X>::ClassName(...) {
   .. 
}

...

// main.cpp file
int main() {
    ClassName<datatype, datatypeT2, int> objectName();
    ...
}
```

- *Class templates*: specify a range of related classes with a single definition (not compileable)
    - Defined by programmer
- *Template classes*: the individual instantiated versions of the class template that are compileable
    - Created by compiler
- Can set defaults types or values for template parameters:
    - `template<typename T=int, int x=10>`
- Template classes Can be used as arguments to other templates since they are valid types once compiled
- Compiler doesn't evaluate class templates unless they are used (methods could be uncompiled if class not instantiated)

## Specialization
- In the below version, a seperate version of `sum()` is provided for string types while the generic template version of `sum()` is provided for other types.
- This reduces code bloat b/c only the necessary implementation will be compiled if a class of that type is instantiated
- You can specialize a method as many times as needed
    - A non-specialized version should still be provided as well
``` c++
template <> std::string Stack<std::string>::sum() const {
  std::string value;
  for (uint32_t i = 0; i < stackTop; ++i) {
    value = stack[i] + value;
  }
  return value;
}

template <typename T> T Stack<T>::sum() const {
  T value = T();
  for (uint32_t i = 0; i < stackTop; ++i) {
    value += stack[i];
  }
  return value;
}

```